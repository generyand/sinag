# ==============================================================================
# Deploy to EC2 with GitHub Environments
# ==============================================================================
# This workflow deploys SINAG to EC2 with environment-specific secrets:
#   - develop branch â†’ staging environment
#   - main branch â†’ production environment (requires approval)
#
# TRIGGERS:
#   - Manual trigger (workflow_dispatch) - bypasses quality gates
#   - After successful build on main or develop branch
#
# QUALITY GATES (for automatic deployments):
#   - âœ… Build workflow must succeed
#   - âœ… CI workflow must succeed (linting, tests, type checking)
#   - âœ… Security workflow must succeed (no critical vulnerabilities)
#
# Manual deployments bypass these checks (use with caution).
# ==============================================================================

name: Deploy to EC2

on:
  # Manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      run_migrations:
        description: "Run database migrations"
        required: false
        default: false
        type: boolean

  # Auto-deploy after successful build
  workflow_run:
    workflows: ["Build and Push to GHCR"]
    types:
      - completed
    branches:
      - main
      - develop

jobs:
  # ==========================================================================
  # Validate all required workflows passed before deployment
  # ==========================================================================
  validate-checks:
    name: Validate Quality Gates
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Only validate for automatic deployments (workflow_run), manual deployments skip validation
    if: github.event_name == 'workflow_run'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate build workflow status
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "::error::Build workflow did not succeed. Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Deployment blocked because the build workflow failed or was cancelled."
            exit 1
          fi
          echo "âœ… Build workflow succeeded"

      - name: Validate CI workflow status
        run: |
          echo "Checking CI workflow status for commit ${{ github.event.workflow_run.head_sha }}..."

          # Get the CI workflow run for this commit
          CI_RUN=$(gh api repos/${{ github.repository }}/actions/workflows/ci.yml/runs \
            --jq ".workflow_runs[] | select(.head_sha == \"${{ github.event.workflow_run.head_sha }}\") | select(.event == \"push\" or .event == \"pull_request\") | .conclusion" \
            --paginate | head -n 1)

          if [ -z "$CI_RUN" ]; then
            echo "::warning::CI workflow run not found for this commit. This might be expected for manual builds."
            echo "Skipping CI validation (manual deployment or CI not yet triggered)"
          elif [ "$CI_RUN" != "success" ]; then
            echo "::error::CI workflow did not succeed. Conclusion: $CI_RUN"
            echo "Deployment blocked because CI checks failed."
            echo "Please ensure all CI checks pass before deploying."
            exit 1
          else
            echo "âœ… CI workflow succeeded"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate security workflow status
        run: |
          echo "Checking Security workflow status for commit ${{ github.event.workflow_run.head_sha }}..."

          # Get the Security workflow run for this commit
          SECURITY_RUN=$(gh api repos/${{ github.repository }}/actions/workflows/security.yml/runs \
            --jq ".workflow_runs[] | select(.head_sha == \"${{ github.event.workflow_run.head_sha }}\") | select(.event == \"push\" or .event == \"pull_request\") | .conclusion" \
            --paginate | head -n 1)

          if [ -z "$SECURITY_RUN" ]; then
            echo "::warning::Security workflow run not found for this commit."
            echo "Skipping security validation (security scan may not have run yet)"
          elif [ "$SECURITY_RUN" != "success" ] && [ "$SECURITY_RUN" != "neutral" ]; then
            echo "::error::Security workflow did not succeed. Conclusion: $SECURITY_RUN"
            echo "Deployment blocked because security scans failed."
            echo "Please review security findings before deploying."
            exit 1
          else
            echo "âœ… Security workflow completed (status: ${SECURITY_RUN:-not found})"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: false

  # ==========================================================================
  # Determine which environment to deploy to
  # ==========================================================================
  setup:
    runs-on: ubuntu-latest
    needs: [validate-checks]
    # Run if: manual trigger OR (automatic trigger AND validation passed)
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'workflow_run' && (needs.validate-checks.result == 'success' || needs.validate-checks.result == 'skipped'))
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      image_tag: ${{ steps.set-env.outputs.image_tag }}
    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger - use selected environment
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            if [ "${{ inputs.environment }}" == "production" ]; then
              echo "image_tag=latest" >> $GITHUB_OUTPUT
            else
              echo "image_tag=develop" >> $GITHUB_OUTPUT
            fi
          elif [ "${{ github.event.workflow_run.head_branch }}" == "main" ]; then
            # Auto-deploy main â†’ production
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "image_tag=latest" >> $GITHUB_OUTPUT
          else
            # Auto-deploy develop â†’ staging
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "image_tag=develop" >> $GITHUB_OUTPUT
          fi

  # ==========================================================================
  # Deploy to staging (auto-deploy, no approval needed)
  # ==========================================================================
  deploy-staging:
    needs: setup
    if: |
      needs.setup.outputs.environment == 'staging' &&
      (
        github.event_name == 'workflow_dispatch' ||
        (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: staging # Uses staging secrets

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Copy docker-compose files to EC2
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "mkdir -p ~/sinag"
          scp -i ~/.ssh/ec2_key docker-compose.prod.yml ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:~/sinag/
          echo "âœ“ Docker compose files copied to EC2"

      - name: Create .env file on EC2
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          cd ~/sinag

          cat > .env << 'EOF'
          # Auto-generated by GitHub Actions - DO NOT EDIT MANUALLY
          # Environment: STAGING
          # Last deployed: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          GITHUB_REPOSITORY=${{ github.repository }}
          IMAGE_TAG=${{ needs.setup.outputs.image_tag }}

          # Environment
          ENVIRONMENT=${{ vars.ENVIRONMENT || 'staging' }}

          # Security
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          FIRST_SUPERUSER_PASSWORD=${{ secrets.FIRST_SUPERUSER_PASSWORD }}
          EXTERNAL_USER_DEFAULT_PASSWORD=${{ secrets.EXTERNAL_USER_DEFAULT_PASSWORD }}

          # CORS
          BACKEND_CORS_ORIGINS=${{ vars.BACKEND_CORS_ORIGINS }}

          # Database & Supabase
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          SUPABASE_URL=${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

          # AI
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          EOF

          echo "âœ“ Environment file created (staging)"
          ENVSSH

      - name: Login to GHCR on EC2
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          echo "âœ“ Logged into GHCR"
          ENVSSH

      - name: Pull and deploy
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          set -e
          cd ~/sinag
          docker compose -f docker-compose.prod.yml pull
          docker compose -f docker-compose.prod.yml down --remove-orphans || true
          docker compose -f docker-compose.prod.yml up -d
          echo "âœ“ Staging deployed"
          ENVSSH

      - name: Run migrations
        if: ${{ inputs.run_migrations == true }}
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          set -e
          cd ~/sinag
          sleep 15
          docker compose -f docker-compose.prod.yml exec -T api alembic upgrade head
          echo "âœ“ Migrations completed"
          ENVSSH

      - name: Health check
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          set -e
          cd ~/sinag
          sleep 10
          for i in 1 2 3; do
            if curl -sf http://localhost/health > /dev/null; then
              echo "âœ“ Staging is healthy!"
              exit 0
            fi
            echo "Health check attempt $i failed, retrying..."
            sleep 5
          done
          echo "âœ— Health check failed after 3 attempts"
          docker compose -f docker-compose.prod.yml ps
          docker compose -f docker-compose.prod.yml logs --tail=20
          exit 1
          ENVSSH

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/ec2_key

      - name: Summary
        run: |
          echo "## ðŸš€ Staging Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** staging" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ needs.setup.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** http://${{ secrets.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY

  # ==========================================================================
  # Deploy to production (requires approval)
  # ==========================================================================
  deploy-production:
    needs: setup
    if: |
      needs.setup.outputs.environment == 'production' &&
      (
        github.event_name == 'workflow_dispatch' ||
        (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: production # Uses production secrets + requires approval

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Copy docker-compose files to EC2
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "mkdir -p ~/sinag"
          scp -i ~/.ssh/ec2_key docker-compose.prod.yml ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:~/sinag/
          echo "âœ“ Docker compose files copied to EC2"

      - name: Create .env file on EC2
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          cd ~/sinag

          cat > .env << 'EOF'
          # Auto-generated by GitHub Actions - DO NOT EDIT MANUALLY
          # Environment: PRODUCTION
          # Last deployed: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          GITHUB_REPOSITORY=${{ github.repository }}
          IMAGE_TAG=${{ needs.setup.outputs.image_tag }}

          # Environment
          ENVIRONMENT=${{ vars.ENVIRONMENT || 'production' }}

          # Security
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          FIRST_SUPERUSER_PASSWORD=${{ secrets.FIRST_SUPERUSER_PASSWORD }}
          EXTERNAL_USER_DEFAULT_PASSWORD=${{ secrets.EXTERNAL_USER_DEFAULT_PASSWORD }}

          # CORS
          BACKEND_CORS_ORIGINS=${{ vars.BACKEND_CORS_ORIGINS }}

          # Database & Supabase
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          SUPABASE_URL=${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

          # AI
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          EOF

          echo "âœ“ Environment file created (production)"
          ENVSSH

      - name: Login to GHCR on EC2
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          echo "âœ“ Logged into GHCR"
          ENVSSH

      - name: Pull and deploy
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          set -e
          cd ~/sinag
          docker compose -f docker-compose.prod.yml pull
          docker compose -f docker-compose.prod.yml down --remove-orphans || true
          docker compose -f docker-compose.prod.yml up -d
          echo "âœ“ Production deployed"
          ENVSSH

      - name: Run migrations
        if: ${{ inputs.run_migrations == true }}
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          set -e
          cd ~/sinag
          sleep 15
          docker compose -f docker-compose.prod.yml exec -T api alembic upgrade head
          echo "âœ“ Migrations completed"
          ENVSSH

      - name: Health check
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENVSSH'
          set -e
          cd ~/sinag
          sleep 10
          for i in 1 2 3; do
            if curl -sf http://localhost/health > /dev/null; then
              echo "âœ“ Production is healthy!"
              exit 0
            fi
            echo "Health check attempt $i failed, retrying..."
            sleep 5
          done
          echo "âœ— Health check failed after 3 attempts"
          docker compose -f docker-compose.prod.yml ps
          docker compose -f docker-compose.prod.yml logs --tail=20
          exit 1
          ENVSSH

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/ec2_key

      - name: Summary
        run: |
          echo "## ðŸš€ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** production" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ needs.setup.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** http://${{ secrets.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
