/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  PatchUsersMePreferencesTourLanguageParams,
  UserPreferencesResponse,
  UserPreferencesUpdate
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get current user's preferences.

Returns user preferences including onboarding tour state, completed tours,
and preferred tour language.
 * @summary Get User Preferences
 */
export const getUsersMePreferences = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<UserPreferencesResponse>(
      {url: `/api/v1/users/me/preferences`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUsersMePreferencesQueryKey = () => {
    return [
    `/api/v1/users/me/preferences`
    ] as const;
    }

    
export const getGetUsersMePreferencesQueryOptions = <TData = Awaited<ReturnType<typeof getUsersMePreferences>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersMePreferences>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersMePreferencesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersMePreferences>>> = ({ signal }) => getUsersMePreferences(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersMePreferences>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersMePreferencesQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersMePreferences>>>
export type GetUsersMePreferencesQueryError = unknown


/**
 * @summary Get User Preferences
 */

export function useGetUsersMePreferences<TData = Awaited<ReturnType<typeof getUsersMePreferences>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersMePreferences>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersMePreferencesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update current user's preferences.

Allows partial updates to user preferences including tour state and language.
 * @summary Update User Preferences
 */
export const patchUsersMePreferences = (
    userPreferencesUpdate: UserPreferencesUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<UserPreferencesResponse>(
      {url: `/api/v1/users/me/preferences`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userPreferencesUpdate
    },
      options);
    }
  


export const getPatchUsersMePreferencesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsersMePreferences>>, TError,{data: UserPreferencesUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof patchUsersMePreferences>>, TError,{data: UserPreferencesUpdate}, TContext> => {

const mutationKey = ['patchUsersMePreferences'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchUsersMePreferences>>, {data: UserPreferencesUpdate}> = (props) => {
          const {data} = props ?? {};

          return  patchUsersMePreferences(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchUsersMePreferencesMutationResult = NonNullable<Awaited<ReturnType<typeof patchUsersMePreferences>>>
    export type PatchUsersMePreferencesMutationBody = UserPreferencesUpdate
    export type PatchUsersMePreferencesMutationError = HTTPValidationError

    /**
 * @summary Update User Preferences
 */
export const usePatchUsersMePreferences = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsersMePreferences>>, TError,{data: UserPreferencesUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchUsersMePreferences>>,
        TError,
        {data: UserPreferencesUpdate},
        TContext
      > => {

      const mutationOptions = getPatchUsersMePreferencesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Mark a specific tour as completed.

Args:
    tour_name: The tour to mark as complete. Options:
        - dashboard: Main dashboard overview tour
        - assessments: Assessment form navigation tour
        - indicatorForm: Indicator form tour
        - rework: Rework workflow tour

Also sets hasSeenTour to true.
 * @summary Mark Tour Complete
 */
export const postUsersMePreferencesTour$TourNameComplete = (
    tourName: 'dashboard' | 'assessments' | 'indicatorForm' | 'rework',
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<UserPreferencesResponse>(
      {url: `/api/v1/users/me/preferences/tour/${tourName}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getPostUsersMePreferencesTourTourNameCompleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTour$TourNameComplete>>, TError,{tourName: 'dashboard' | 'assessments' | 'indicatorForm' | 'rework'}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTour$TourNameComplete>>, TError,{tourName: 'dashboard' | 'assessments' | 'indicatorForm' | 'rework'}, TContext> => {

const mutationKey = ['postUsersMePreferencesTourTourNameComplete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersMePreferencesTour$TourNameComplete>>, {tourName: 'dashboard' | 'assessments' | 'indicatorForm' | 'rework'}> = (props) => {
          const {tourName} = props ?? {};

          return  postUsersMePreferencesTour$TourNameComplete(tourName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersMePreferencesTourTourNameCompleteMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersMePreferencesTour$TourNameComplete>>>
    
    export type PostUsersMePreferencesTourTourNameCompleteMutationError = HTTPValidationError

    /**
 * @summary Mark Tour Complete
 */
export const usePostUsersMePreferencesTourTourNameComplete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTour$TourNameComplete>>, TError,{tourName: 'dashboard' | 'assessments' | 'indicatorForm' | 'rework'}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postUsersMePreferencesTour$TourNameComplete>>,
        TError,
        {tourName: 'dashboard' | 'assessments' | 'indicatorForm' | 'rework'},
        TContext
      > => {

      const mutationOptions = getPostUsersMePreferencesTourTourNameCompleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Mark that the user has seen the tour.

Sets hasSeenTour to true without marking any specific tour as complete.
Useful when user skips or dismisses the tour.
 * @summary Mark Tour Seen
 */
export const postUsersMePreferencesTourSeen = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<UserPreferencesResponse>(
      {url: `/api/v1/users/me/preferences/tour/seen`, method: 'POST', signal
    },
      options);
    }
  


export const getPostUsersMePreferencesTourSeenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTourSeen>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTourSeen>>, TError,void, TContext> => {

const mutationKey = ['postUsersMePreferencesTourSeen'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersMePreferencesTourSeen>>, void> = () => {
          

          return  postUsersMePreferencesTourSeen(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersMePreferencesTourSeenMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersMePreferencesTourSeen>>>
    
    export type PostUsersMePreferencesTourSeenMutationError = unknown

    /**
 * @summary Mark Tour Seen
 */
export const usePostUsersMePreferencesTourSeen = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTourSeen>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postUsersMePreferencesTourSeen>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostUsersMePreferencesTourSeenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Reset all tour completion state.

Allows user to restart all tours from the beginning.
Preserves the tour language preference.
 * @summary Reset Tour State
 */
export const postUsersMePreferencesTourReset = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<UserPreferencesResponse>(
      {url: `/api/v1/users/me/preferences/tour/reset`, method: 'POST', signal
    },
      options);
    }
  


export const getPostUsersMePreferencesTourResetMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTourReset>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTourReset>>, TError,void, TContext> => {

const mutationKey = ['postUsersMePreferencesTourReset'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersMePreferencesTourReset>>, void> = () => {
          

          return  postUsersMePreferencesTourReset(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersMePreferencesTourResetMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersMePreferencesTourReset>>>
    
    export type PostUsersMePreferencesTourResetMutationError = unknown

    /**
 * @summary Reset Tour State
 */
export const usePostUsersMePreferencesTourReset = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersMePreferencesTourReset>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postUsersMePreferencesTourReset>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostUsersMePreferencesTourResetMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Set the preferred language for tour content.

Supported languages:
- en: English
- fil: Filipino (Tagalog)
- ceb: Cebuano (Bisaya)
 * @summary Set Tour Language
 */
export const patchUsersMePreferencesTourLanguage = (
    params: PatchUsersMePreferencesTourLanguageParams,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<UserPreferencesResponse>(
      {url: `/api/v1/users/me/preferences/tour/language`, method: 'PATCH',
        params
    },
      options);
    }
  


export const getPatchUsersMePreferencesTourLanguageMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsersMePreferencesTourLanguage>>, TError,{params: PatchUsersMePreferencesTourLanguageParams}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof patchUsersMePreferencesTourLanguage>>, TError,{params: PatchUsersMePreferencesTourLanguageParams}, TContext> => {

const mutationKey = ['patchUsersMePreferencesTourLanguage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchUsersMePreferencesTourLanguage>>, {params: PatchUsersMePreferencesTourLanguageParams}> = (props) => {
          const {params} = props ?? {};

          return  patchUsersMePreferencesTourLanguage(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchUsersMePreferencesTourLanguageMutationResult = NonNullable<Awaited<ReturnType<typeof patchUsersMePreferencesTourLanguage>>>
    
    export type PatchUsersMePreferencesTourLanguageMutationError = HTTPValidationError

    /**
 * @summary Set Tour Language
 */
export const usePatchUsersMePreferencesTourLanguage = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsersMePreferencesTourLanguage>>, TError,{params: PatchUsersMePreferencesTourLanguageParams}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchUsersMePreferencesTourLanguage>>,
        TError,
        {params: PatchUsersMePreferencesTourLanguageParams},
        TContext
      > => {

      const mutationOptions = getPatchUsersMePreferencesTourLanguageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    