/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssessmentDashboardResponse,
  AssessmentResponse,
  AssessmentResponseCreate,
  AssessmentResponseUpdate,
  AssessmentSubmissionValidation,
  CompletenessValidationResponse,
  DeleteAssessmentsMovsMovId200,
  GetAnswersResponse,
  GetAssessmentsAssessmentIdAnswersParams,
  GetAssessmentsList200Item,
  GetAssessmentsListParams,
  GetAssessmentsMyAssessment200,
  HTTPValidationError,
  MOVCreate,
  Mov,
  PostAssessmentsAssessmentIdAnswersParams,
  PostAssessmentsIdGenerateInsights202,
  RequestReworkRequest,
  RequestReworkResponse,
  ResubmitAssessmentResponse,
  SaveAnswersRequest,
  SaveAnswersResponse,
  SubmissionStatusResponse,
  SubmitAssessmentResponse
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get dashboard data for the logged-in BLGU user's assessment.

Returns dashboard-specific data optimized for overview and progress tracking:
- Progress statistics (completed/total indicators)
- Governance area progress summaries
- Performance metrics (responses requiring rework, with feedback, with MOVs)
- Recent feedback summaries
- Assessment status and metadata

This endpoint automatically creates an assessment if one doesn't exist
for the BLGU user.
 * @summary Get Assessment Dashboard
 */
export const getAssessmentsDashboard = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentDashboardResponse>(
      {url: `http://localhost:8000/api/v1/assessments/dashboard`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsDashboardQueryKey = () => {
    return [`http://localhost:8000/api/v1/assessments/dashboard`] as const;
    }

    
export const getGetAssessmentsDashboardQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsDashboardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsDashboard>>> = ({ signal }) => getAssessmentsDashboard(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsDashboard>>>
export type GetAssessmentsDashboardQueryError = unknown


/**
 * @summary Get Assessment Dashboard
 */

export function useGetAssessmentsDashboard<TData = Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsDashboardQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get the complete assessment data for the logged-in BLGU user.

Returns the full assessment data including:
- Assessment status and metadata
- All governance areas with their indicators
- Form schemas for each indicator
- Existing response data for each indicator
- MOVs (Means of Verification) for each response
- Feedback comments from assessors

This endpoint automatically creates an assessment if one doesn't exist
for the BLGU user.
 * @summary Get My Assessment
 */
export const getAssessmentsMyAssessment = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetAssessmentsMyAssessment200>(
      {url: `http://localhost:8000/api/v1/assessments/my-assessment`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsMyAssessmentQueryKey = () => {
    return [`http://localhost:8000/api/v1/assessments/my-assessment`] as const;
    }

    
export const getGetAssessmentsMyAssessmentQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsMyAssessmentQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>> = ({ signal }) => getAssessmentsMyAssessment(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsMyAssessmentQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>>
export type GetAssessmentsMyAssessmentQueryError = unknown


/**
 * @summary Get My Assessment
 */

export function useGetAssessmentsMyAssessment<TData = Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsMyAssessmentQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get a specific assessment response by ID.

Returns the assessment response with all related data including:
- Response data (JSON)
- Completion status
- MOVs (Means of Verification)
- Feedback comments
 * @summary Get Assessment Response
 */
export const getAssessmentsResponses$ResponseId = (
    responseId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsResponsesResponseIdQueryKey = (responseId: number,) => {
    return [`http://localhost:8000/api/v1/assessments/responses/${responseId}`] as const;
    }

    
export const getGetAssessmentsResponsesResponseIdQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError = HTTPValidationError>(responseId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsResponsesResponseIdQueryKey(responseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>> = ({ signal }) => getAssessmentsResponses$ResponseId(responseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(responseId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsResponsesResponseIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>>
export type GetAssessmentsResponsesResponseIdQueryError = HTTPValidationError


/**
 * @summary Get Assessment Response
 */

export function useGetAssessmentsResponsesResponseId<TData = Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError = HTTPValidationError>(
 responseId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsResponsesResponseIdQueryOptions(responseId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an assessment response with validation.

Updates the response data and validates it against the indicator's form schema.
The response data must conform to the JSON schema defined in the indicator's
form_schema field.

Business Rules:
- Only responses belonging to the current user's assessment can be updated
- Response data is validated against the indicator's form schema
- Completion status is automatically updated based on response data
 * @summary Update Assessment Response
 */
export const putAssessmentsResponses$ResponseId = (
    responseId: number,
    assessmentResponseUpdate: AssessmentResponseUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assessmentResponseUpdate
    },
      options);
    }
  


export const getPutAssessmentsResponsesResponseIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext> => {

const mutationKey = ['putAssessmentsResponsesResponseId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, {responseId: number;data: AssessmentResponseUpdate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  putAssessmentsResponses$ResponseId(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutAssessmentsResponsesResponseIdMutationResult = NonNullable<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>>
    export type PutAssessmentsResponsesResponseIdMutationBody = AssessmentResponseUpdate
    export type PutAssessmentsResponsesResponseIdMutationError = HTTPValidationError

    /**
 * @summary Update Assessment Response
 */
export const usePutAssessmentsResponsesResponseId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>,
        TError,
        {responseId: number;data: AssessmentResponseUpdate},
        TContext
      > => {

      const mutationOptions = getPutAssessmentsResponsesResponseIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Create a new assessment response.

Creates a new response for a specific indicator in the user's assessment.
The response data is validated against the indicator's form schema.
 * @summary Create Assessment Response
 */
export const postAssessmentsResponses = (
    assessmentResponseCreate: AssessmentResponseCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assessmentResponseCreate, signal
    },
      options);
    }
  


export const getPostAssessmentsResponsesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext> => {

const mutationKey = ['postAssessmentsResponses'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsResponses>>, {data: AssessmentResponseCreate}> = (props) => {
          const {data} = props ?? {};

          return  postAssessmentsResponses(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsResponsesMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsResponses>>>
    export type PostAssessmentsResponsesMutationBody = AssessmentResponseCreate
    export type PostAssessmentsResponsesMutationError = HTTPValidationError

    /**
 * @summary Create Assessment Response
 */
export const usePostAssessmentsResponses = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsResponses>>,
        TError,
        {data: AssessmentResponseCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsResponsesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Submit the assessment for review.

Runs a preliminary compliance check before submission:
- Ensures no "YES" answers exist without corresponding MOVs (Means of Verification)
- Updates assessment status to "Submitted for Review"
- Sets submission timestamp

Returns validation results with any errors or warnings.
 * @summary Submit Assessment
 */
export const postAssessmentsSubmit = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentSubmissionValidation>(
      {url: `http://localhost:8000/api/v1/assessments/submit`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsSubmitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext> => {

const mutationKey = ['postAssessmentsSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsSubmit>>, void> = () => {
          

          return  postAssessmentsSubmit(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsSubmit>>>
    
    export type PostAssessmentsSubmitMutationError = unknown

    /**
 * @summary Submit Assessment
 */
export const usePostAssessmentsSubmit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsSubmit>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostAssessmentsSubmitMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Upload a MOV (Means of Verification) file for an assessment response.

Creates a record of the uploaded file in the database. The actual file
upload to Supabase Storage should be handled by the frontend before
calling this endpoint.
 * @summary Upload Mov
 */
export const postAssessmentsResponses$ResponseIdMovs = (
    responseId: number,
    mOVCreate: MOVCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<Mov>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}/movs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mOVCreate, signal
    },
      options);
    }
  


export const getPostAssessmentsResponsesResponseIdMovsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext> => {

const mutationKey = ['postAssessmentsResponsesResponseIdMovs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, {responseId: number;data: MOVCreate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  postAssessmentsResponses$ResponseIdMovs(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsResponsesResponseIdMovsMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>>
    export type PostAssessmentsResponsesResponseIdMovsMutationBody = MOVCreate
    export type PostAssessmentsResponsesResponseIdMovsMutationError = HTTPValidationError

    /**
 * @summary Upload Mov
 */
export const usePostAssessmentsResponsesResponseIdMovs = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>,
        TError,
        {responseId: number;data: MOVCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsResponsesResponseIdMovsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Delete a MOV (Means of Verification) file.

Removes the MOV record from the database. The actual file deletion
from Supabase Storage should be handled separately.
 * @summary Delete Mov
 */
export const deleteAssessmentsMovs$MovId = (
    movId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<DeleteAssessmentsMovsMovId200>(
      {url: `http://localhost:8000/api/v1/assessments/movs/${movId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAssessmentsMovsMovIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext> => {

const mutationKey = ['deleteAssessmentsMovsMovId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, {movId: number}> = (props) => {
          const {movId} = props ?? {};

          return  deleteAssessmentsMovs$MovId(movId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssessmentsMovsMovIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>>
    
    export type DeleteAssessmentsMovsMovIdMutationError = HTTPValidationError

    /**
 * @summary Delete Mov
 */
export const useDeleteAssessmentsMovsMovId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>,
        TError,
        {movId: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssessmentsMovsMovIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get all validated assessments with compliance status.

Returns a list of all validated assessments with their compliance status,
area results, and barangay information. Used for MLGOO reports dashboard.

Args:
    status: Filter by assessment status (defaults to VALIDATED)
    db: Database session
    current_user: Current admin/MLGOO user

Returns:
    List of assessment dictionaries with compliance data
 * @summary Get All Validated Assessments
 */
export const getAssessmentsList = (
    params?: GetAssessmentsListParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetAssessmentsList200Item[]>(
      {url: `http://localhost:8000/api/v1/assessments/list`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAssessmentsListQueryKey = (params?: GetAssessmentsListParams,) => {
    return [`http://localhost:8000/api/v1/assessments/list`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAssessmentsListQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsList>>, TError = HTTPValidationError>(params?: GetAssessmentsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsList>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsList>>> = ({ signal }) => getAssessmentsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsList>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsListQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsList>>>
export type GetAssessmentsListQueryError = HTTPValidationError


/**
 * @summary Get All Validated Assessments
 */

export function useGetAssessmentsList<TData = Awaited<ReturnType<typeof getAssessmentsList>>, TError = HTTPValidationError>(
 params?: GetAssessmentsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsList>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsListQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Generate AI-powered insights for a validated assessment.

This endpoint dispatches a background Celery task to generate AI insights
using the Gemini API. The task runs asynchronously and results are stored
in the ai_recommendations field.

**Business Rules:**
- Only works for assessments with VALIDATED status
- Returns 202 Accepted immediately (asynchronous processing)
- Task includes automatic retry logic (max 3 attempts with exponential backoff)
- Results are cached to avoid duplicate API calls

**Response:**
- Immediately returns 202 Accepted with task information
- Frontend should poll assessment endpoint to check for ai_recommendations field

Args:
    id: Assessment ID
    db: Database session
    current_user: Current authenticated user

Returns:
    dict: Task dispatch confirmation
 * @summary Generate Insights
 */
export const postAssessments$IdGenerateInsights = (
    id: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostAssessmentsIdGenerateInsights202>(
      {url: `http://localhost:8000/api/v1/assessments/${id}/generate-insights`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsIdGenerateInsightsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>, TError,{id: number}, TContext> => {

const mutationKey = ['postAssessmentsIdGenerateInsights'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postAssessments$IdGenerateInsights(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsIdGenerateInsightsMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>>
    
    export type PostAssessmentsIdGenerateInsightsMutationError = HTTPValidationError

    /**
 * @summary Generate Insights
 */
export const usePostAssessmentsIdGenerateInsights = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsIdGenerateInsightsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Save form responses for an assessment.

**Permissions**:
- BLGU users can save answers for their own assessments
- Assessors can save answers (for table validation)

**Path Parameters**:
- assessment_id: ID of the assessment

**Query Parameters**:
- indicator_id: ID of the indicator

**Request Body**:
```json
{
  "responses": [
    {"field_id": "field1", "value": "text response"},
    {"field_id": "field2", "value": 42},
    {"field_id": "field3", "value": ["option1", "option2"]}
  ]
}
```

**Field Type Validation**:
- text/textarea: value must be string
- number: value must be numeric (int or float)
- date: value must be ISO date string
- select/radio: value must be string matching one of the field's option IDs
- checkbox: value must be array of strings matching the field's option IDs

**Returns**: Confirmation with count of saved fields

**Raises**:
- 400: Assessment is locked for editing
- 403: User not authorized to modify this assessment
- 404: Assessment or indicator not found
- 422: Field validation errors (field not found, type mismatch, invalid option)
 * @summary Save Assessment Answers
 */
export const postAssessments$AssessmentIdAnswers = (
    assessmentId: number,
    saveAnswersRequest: SaveAnswersRequest,
    params: PostAssessmentsAssessmentIdAnswersParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<SaveAnswersResponse>(
      {url: `http://localhost:8000/api/v1/assessments/${assessmentId}/answers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: saveAnswersRequest,
        params, signal
    },
      options);
    }
  


export const getPostAssessmentsAssessmentIdAnswersMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdAnswers>>, TError,{assessmentId: number;data: SaveAnswersRequest;params: PostAssessmentsAssessmentIdAnswersParams}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdAnswers>>, TError,{assessmentId: number;data: SaveAnswersRequest;params: PostAssessmentsAssessmentIdAnswersParams}, TContext> => {

const mutationKey = ['postAssessmentsAssessmentIdAnswers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessments$AssessmentIdAnswers>>, {assessmentId: number;data: SaveAnswersRequest;params: PostAssessmentsAssessmentIdAnswersParams}> = (props) => {
          const {assessmentId,data,params} = props ?? {};

          return  postAssessments$AssessmentIdAnswers(assessmentId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsAssessmentIdAnswersMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessments$AssessmentIdAnswers>>>
    export type PostAssessmentsAssessmentIdAnswersMutationBody = SaveAnswersRequest
    export type PostAssessmentsAssessmentIdAnswersMutationError = HTTPValidationError

    /**
 * @summary Save Assessment Answers
 */
export const usePostAssessmentsAssessmentIdAnswers = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdAnswers>>, TError,{assessmentId: number;data: SaveAnswersRequest;params: PostAssessmentsAssessmentIdAnswersParams}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessments$AssessmentIdAnswers>>,
        TError,
        {assessmentId: number;data: SaveAnswersRequest;params: PostAssessmentsAssessmentIdAnswersParams},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsAssessmentIdAnswersMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Retrieve saved form responses for a specific indicator in an assessment.

**Permissions**:
- BLGU users can retrieve answers for their own assessments
- Assessors can retrieve answers for any assessment

**Path Parameters**:
- assessment_id: ID of the assessment

**Query Parameters**:
- indicator_id: ID of the indicator

**Returns**:
```json
{
  "assessment_id": 1,
  "indicator_id": 5,
  "responses": [
    {"field_id": "field1", "value": "text response"},
    {"field_id": "field2", "value": 42}
  ],
  "created_at": "2025-01-08T12:00:00",
  "updated_at": "2025-01-08T12:30:00"
}
```

Returns empty array if no responses saved yet.

**Raises**:
- 403: User not authorized to view this assessment
- 404: Assessment not found
 * @summary Get Assessment Answers
 */
export const getAssessments$AssessmentIdAnswers = (
    assessmentId: number,
    params: GetAssessmentsAssessmentIdAnswersParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetAnswersResponse>(
      {url: `http://localhost:8000/api/v1/assessments/${assessmentId}/answers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAssessmentsAssessmentIdAnswersQueryKey = (assessmentId: number,
    params: GetAssessmentsAssessmentIdAnswersParams,) => {
    return [`http://localhost:8000/api/v1/assessments/${assessmentId}/answers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAssessmentsAssessmentIdAnswersQueryOptions = <TData = Awaited<ReturnType<typeof getAssessments$AssessmentIdAnswers>>, TError = HTTPValidationError>(assessmentId: number,
    params: GetAssessmentsAssessmentIdAnswersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessments$AssessmentIdAnswers>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsAssessmentIdAnswersQueryKey(assessmentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessments$AssessmentIdAnswers>>> = ({ signal }) => getAssessments$AssessmentIdAnswers(assessmentId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assessmentId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessments$AssessmentIdAnswers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsAssessmentIdAnswersQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessments$AssessmentIdAnswers>>>
export type GetAssessmentsAssessmentIdAnswersQueryError = HTTPValidationError


/**
 * @summary Get Assessment Answers
 */

export function useGetAssessmentsAssessmentIdAnswers<TData = Awaited<ReturnType<typeof getAssessments$AssessmentIdAnswers>>, TError = HTTPValidationError>(
 assessmentId: number,
    params: GetAssessmentsAssessmentIdAnswersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessments$AssessmentIdAnswers>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsAssessmentIdAnswersQueryOptions(assessmentId,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Validate completeness of all indicators in an assessment.

Checks if all required fields are filled for all indicators.
Does NOT expose compliance status (Pass/Fail) - only completeness.

**Permissions**: All authenticated users

**Path Parameters**:
- assessment_id: ID of the assessment

**Returns**:
```json
{
  "is_complete": false,
  "total_indicators": 10,
  "complete_indicators": 7,
  "incomplete_indicators": 3,
  "incomplete_details": [
    {
      "indicator_id": 5,
      "indicator_title": "Financial Management",
      "missing_required_fields": ["field1", "field2"]
    }
  ]
}
```

**Raises**:
- 404: Assessment not found
 * @summary Validate Assessment Completeness
 */
export const postAssessments$AssessmentIdValidateCompleteness = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<CompletenessValidationResponse>(
      {url: `http://localhost:8000/api/v1/assessments/${assessmentId}/validate-completeness`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsAssessmentIdValidateCompletenessMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdValidateCompleteness>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdValidateCompleteness>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessmentsAssessmentIdValidateCompleteness'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessments$AssessmentIdValidateCompleteness>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessments$AssessmentIdValidateCompleteness(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsAssessmentIdValidateCompletenessMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessments$AssessmentIdValidateCompleteness>>>
    
    export type PostAssessmentsAssessmentIdValidateCompletenessMutationError = HTTPValidationError

    /**
 * @summary Validate Assessment Completeness
 */
export const usePostAssessmentsAssessmentIdValidateCompleteness = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdValidateCompleteness>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessments$AssessmentIdValidateCompleteness>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsAssessmentIdValidateCompletenessMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Submit an assessment for assessor review (Story 5.5).

This endpoint allows a BLGU user to submit their completed assessment.
The assessment must pass validation (all indicators complete, all MOVs uploaded)
before submission is allowed.

Authorization:
    - BLGU_USER role required
    - User must own the assessment (assessment.blgu_user_id == user.id)

Workflow:
    1. Validate user authorization
    2. Validate assessment completeness using SubmissionValidationService
    3. If valid, update status to SUBMITTED and set submitted_at timestamp
    4. Lock assessment for editing (is_locked property becomes True)
    5. Return success response

Args:
    assessment_id: ID of the assessment to submit
    current_user: Current authenticated user
    db: Database session

Returns:
    SubmitAssessmentResponse with success status and timestamp

Raises:
    HTTPException 403: User not authorized to submit this assessment
    HTTPException 400: Assessment validation failed (incomplete or missing MOVs)
    HTTPException 404: Assessment not found
 * @summary Submit Assessment
 */
export const postAssessments$AssessmentIdSubmit = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<SubmitAssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/${assessmentId}/submit`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsAssessmentIdSubmitMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessmentsAssessmentIdSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessments$AssessmentIdSubmit(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsAssessmentIdSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>>
    
    export type PostAssessmentsAssessmentIdSubmitMutationError = HTTPValidationError

    /**
 * @summary Submit Assessment
 */
export const usePostAssessmentsAssessmentIdSubmit = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsAssessmentIdSubmitMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Request rework on a submitted assessment (Story 5.6).

This endpoint allows an assessor/validator to request changes to a BLGU submission.
Only one rework cycle is allowed per assessment (enforced by rework_count check).

Authorization:
    - ASSESSOR, VALIDATOR, or MLGOO_DILG role required
    - BLGU_USER role is forbidden

Business Rules:
    - Assessment must be in SUBMITTED status
    - rework_count must be less than 1 (only one rework cycle allowed)
    - Comments are required (min 10 characters)

Workflow:
    1. Validate user authorization (role check)
    2. Load assessment and check status is SUBMITTED
    3. Check rework_count < 1
    4. Update status to REWORK
    5. Increment rework_count
    6. Record rework_requested_by, rework_requested_at, rework_comments
    7. Unlock assessment for BLGU editing (is_locked becomes False)
    8. Return success response

Args:
    assessment_id: ID of the assessment to request rework on
    request_data: Request body containing rework comments
    current_user: Current authenticated user
    db: Database session

Returns:
    RequestReworkResponse with success status and rework details

Raises:
    HTTPException 403: User not authorized (must be assessor/validator)
    HTTPException 400: Invalid status or rework limit reached
    HTTPException 404: Assessment not found
 * @summary Request Rework
 */
export const postAssessments$AssessmentIdRequestRework = (
    assessmentId: number,
    requestReworkRequest: RequestReworkRequest,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<RequestReworkResponse>(
      {url: `http://localhost:8000/api/v1/assessments/${assessmentId}/request-rework`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: requestReworkRequest, signal
    },
      options);
    }
  


export const getPostAssessmentsAssessmentIdRequestReworkMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdRequestRework>>, TError,{assessmentId: number;data: RequestReworkRequest}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdRequestRework>>, TError,{assessmentId: number;data: RequestReworkRequest}, TContext> => {

const mutationKey = ['postAssessmentsAssessmentIdRequestRework'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessments$AssessmentIdRequestRework>>, {assessmentId: number;data: RequestReworkRequest}> = (props) => {
          const {assessmentId,data} = props ?? {};

          return  postAssessments$AssessmentIdRequestRework(assessmentId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsAssessmentIdRequestReworkMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessments$AssessmentIdRequestRework>>>
    export type PostAssessmentsAssessmentIdRequestReworkMutationBody = RequestReworkRequest
    export type PostAssessmentsAssessmentIdRequestReworkMutationError = HTTPValidationError

    /**
 * @summary Request Rework
 */
export const usePostAssessmentsAssessmentIdRequestRework = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdRequestRework>>, TError,{assessmentId: number;data: RequestReworkRequest}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessments$AssessmentIdRequestRework>>,
        TError,
        {assessmentId: number;data: RequestReworkRequest},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsAssessmentIdRequestReworkMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Resubmit an assessment after completing rework (Story 5.7).

This endpoint allows a BLGU user to resubmit their assessment after
addressing the assessor's rework comments. The assessment must be in
REWORK status and pass validation again.

Authorization:
    - BLGU_USER role required
    - User must own the assessment

Business Rules:
    - Assessment must be in REWORK status
    - Assessment must pass validation (completeness + MOVs)
    - No further rework is allowed after resubmission (rework_count = 1)

Workflow:
    1. Validate user authorization
    2. Check assessment status is REWORK
    3. Validate completeness using SubmissionValidationService
    4. Update status back to SUBMITTED
    5. Update submitted_at timestamp
    6. Lock assessment again (is_locked becomes True)
    7. Return success response

Args:
    assessment_id: ID of the assessment to resubmit
    current_user: Current authenticated user
    db: Database session

Returns:
    ResubmitAssessmentResponse with success status and rework count

Raises:
    HTTPException 403: User not authorized
    HTTPException 400: Invalid status or validation failed
    HTTPException 404: Assessment not found
 * @summary Resubmit Assessment
 */
export const postAssessments$AssessmentIdResubmit = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<ResubmitAssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/${assessmentId}/resubmit`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsAssessmentIdResubmitMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdResubmit>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdResubmit>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessmentsAssessmentIdResubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessments$AssessmentIdResubmit>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessments$AssessmentIdResubmit(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsAssessmentIdResubmitMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessments$AssessmentIdResubmit>>>
    
    export type PostAssessmentsAssessmentIdResubmitMutationError = HTTPValidationError

    /**
 * @summary Resubmit Assessment
 */
export const usePostAssessmentsAssessmentIdResubmit = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdResubmit>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessments$AssessmentIdResubmit>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsAssessmentIdResubmitMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get the submission status of an assessment (Story 5.8).

This endpoint provides comprehensive information about an assessment's submission state,
including:
- Current status (DRAFT, SUBMITTED, IN_REVIEW, REWORK, COMPLETED)
- Whether the assessment is locked for editing
- Rework information (count, comments, timestamp, requester)
- Validation results (completeness check)

This allows BLGU users to:
- Check what needs to be completed before submission
- View rework feedback from assessors
- Understand current assessment state

This allows Assessors to:
- Check assessment status before taking action
- View validation details

Authorization:
- BLGU_USER: Can only check their own assessments
- ASSESSOR/VALIDATOR/MLGOO_DILG: Can check any assessment

Args:
    assessment_id: The ID of the assessment to check
    current_user: Current authenticated user
    db: Database session

Returns:
    SubmissionStatusResponse with comprehensive status information

Raises:
    HTTPException 404: Assessment not found
    HTTPException 403: BLGU user trying to access another barangay's assessment
 * @summary Get Submission Status
 */
export const getAssessments$AssessmentIdSubmissionStatus = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<SubmissionStatusResponse>(
      {url: `http://localhost:8000/api/v1/assessments/${assessmentId}/submission-status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsAssessmentIdSubmissionStatusQueryKey = (assessmentId: number,) => {
    return [`http://localhost:8000/api/v1/assessments/${assessmentId}/submission-status`] as const;
    }

    
export const getGetAssessmentsAssessmentIdSubmissionStatusQueryOptions = <TData = Awaited<ReturnType<typeof getAssessments$AssessmentIdSubmissionStatus>>, TError = HTTPValidationError>(assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessments$AssessmentIdSubmissionStatus>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsAssessmentIdSubmissionStatusQueryKey(assessmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessments$AssessmentIdSubmissionStatus>>> = ({ signal }) => getAssessments$AssessmentIdSubmissionStatus(assessmentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assessmentId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessments$AssessmentIdSubmissionStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsAssessmentIdSubmissionStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessments$AssessmentIdSubmissionStatus>>>
export type GetAssessmentsAssessmentIdSubmissionStatusQueryError = HTTPValidationError


/**
 * @summary Get Submission Status
 */

export function useGetAssessmentsAssessmentIdSubmissionStatus<TData = Awaited<ReturnType<typeof getAssessments$AssessmentIdSubmissionStatus>>, TError = HTTPValidationError>(
 assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessments$AssessmentIdSubmissionStatus>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsAssessmentIdSubmissionStatusQueryOptions(assessmentId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



