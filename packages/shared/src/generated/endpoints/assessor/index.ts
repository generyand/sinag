/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AnnotationCreate,
  AnnotationResponse,
  AnnotationUpdate,
  AssessmentDetailsResponse,
  AssessorAnalyticsResponse,
  AssessorQueueItem,
  BodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost,
  BodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost,
  GetAssessorDashboardParams,
  GetAssessorHistoryParams,
  GetAssessorQueueParams,
  GetAssessorStatsParams,
  HTTPValidationError,
  MOVAssessorFeedbackResponse,
  MOVAssessorFeedbackUpdate,
  MOVCreate,
  MOVUploadResponse,
  MunicipalOverviewDashboard,
  ReviewHistoryDetail,
  ReviewHistoryResponse,
  ValidationRequest,
  ValidationResponse
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get the assessor's secure submissions queue.

Returns a list of submissions filtered by the assessor's governance area
and optionally by assessment year.
 * @summary Get Assessor Queue
 */
export const getAssessorQueue = (
    params?: GetAssessorQueueParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessorQueueItem[]>(
      {url: `/api/v1/assessor/queue`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetAssessorQueueQueryKey = (params?: GetAssessorQueueParams,) => {
    return [
    `/api/v1/assessor/queue`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAssessorQueueQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorQueue>>, TError = HTTPValidationError>(params?: GetAssessorQueueParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorQueue>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorQueueQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorQueue>>> = ({ signal }) => getAssessorQueue(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorQueue>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorQueueQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorQueue>>>
export type GetAssessorQueueQueryError = HTTPValidationError


/**
 * @summary Get Assessor Queue
 */

export function useGetAssessorQueue<TData = Awaited<ReturnType<typeof getAssessorQueue>>, TError = HTTPValidationError>(
 params?: GetAssessorQueueParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorQueue>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorQueueQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get statistics for the assessor/validator.

For area-specific assessors (after workflow restructuring), returns:
- validated_count: Number of assessments where the assessor has completed their governance area

For system-wide validators, returns:
- validated_count: 0 (not applicable)
 * @summary Get Assessor Stats
 */
export const getAssessorStats = (
    params?: GetAssessorStatsParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<unknown>(
      {url: `/api/v1/assessor/stats`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetAssessorStatsQueryKey = (params?: GetAssessorStatsParams,) => {
    return [
    `/api/v1/assessor/stats`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAssessorStatsQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorStats>>, TError = HTTPValidationError>(params?: GetAssessorStatsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorStats>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorStatsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorStats>>> = ({ signal }) => getAssessorStats(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorStats>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorStats>>>
export type GetAssessorStatsQueryError = HTTPValidationError


/**
 * @summary Get Assessor Stats
 */

export function useGetAssessorStats<TData = Awaited<ReturnType<typeof getAssessorStats>>, TError = HTTPValidationError>(
 params?: GetAssessorStatsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorStats>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorStatsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Validate an assessment response.

Accepts validation status (Pass/Fail/Conditional), public comment, assessor remarks, and optional response_data.
Saves public comment to the feedback_comments table.
Assessor remarks are saved to the assessment_response for validators to review.
Response data (checklist) is saved to assessment_response.response_data if provided.

Validation Rules:
- If validation_status is FAIL or CONDITIONAL, a non-empty public_comment is recommended
- Comments are enforced at finalization, not on draft saves
 * @summary Validate Assessment Response
 */
export const postAssessorAssessmentResponses$ResponseIdValidate = (
    responseId: number,
    validationRequest: ValidationRequest,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<ValidationResponse>(
      {url: `/api/v1/assessor/assessment-responses/${responseId}/validate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: validationRequest, signal
    },
      options);
    }
  


export const getPostAssessorAssessmentResponsesResponseIdValidateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>, TError,{responseId: number;data: ValidationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>, TError,{responseId: number;data: ValidationRequest}, TContext> => {

const mutationKey = ['postAssessorAssessmentResponsesResponseIdValidate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>, {responseId: number;data: ValidationRequest}> = (props) => {
          const {responseId,data} = props ?? {};

          return  postAssessorAssessmentResponses$ResponseIdValidate(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentResponsesResponseIdValidateMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>>
    export type PostAssessorAssessmentResponsesResponseIdValidateMutationBody = ValidationRequest
    export type PostAssessorAssessmentResponsesResponseIdValidateMutationError = HTTPValidationError

    /**
 * @summary Validate Assessment Response
 */
export const usePostAssessorAssessmentResponsesResponseIdValidate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>, TError,{responseId: number;data: ValidationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>,
        TError,
        {responseId: number;data: ValidationRequest},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentResponsesResponseIdValidateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Upload a MOV (Means of Verification) for an assessment response.

Allows assessors to upload MOVs for assessment responses they are reviewing.
The assessor must have permission to review responses in the same governance
area as the assessment response's indicator.

Note: The actual file upload to Supabase Storage should be handled by the
frontend before calling this endpoint. This endpoint is for JSON-based uploads.
For multipart file uploads, use the /movs/upload endpoint.
 * @summary Upload Mov For Assessor
 */
export const postAssessorAssessmentResponses$ResponseIdMovs = (
    responseId: number,
    mOVCreate: MOVCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<MOVUploadResponse>(
      {url: `/api/v1/assessor/assessment-responses/${responseId}/movs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mOVCreate, signal
    },
      options);
    }
  


export const getPostAssessorAssessmentResponsesResponseIdMovsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext> => {

const mutationKey = ['postAssessorAssessmentResponsesResponseIdMovs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>, {responseId: number;data: MOVCreate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  postAssessorAssessmentResponses$ResponseIdMovs(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentResponsesResponseIdMovsMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>>
    export type PostAssessorAssessmentResponsesResponseIdMovsMutationBody = MOVCreate
    export type PostAssessorAssessmentResponsesResponseIdMovsMutationError = HTTPValidationError

    /**
 * @summary Upload Mov For Assessor
 */
export const usePostAssessorAssessmentResponsesResponseIdMovs = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>,
        TError,
        {responseId: number;data: MOVCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentResponsesResponseIdMovsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Upload a MOV file via multipart/form-data for an assessment response.

This endpoint accepts a file upload and handles the complete flow:
1. Validates assessor permissions (using existing firewall in deps.py)
2. Uploads file to Supabase Storage via storage_service
3. Creates MOV record marked as "Uploaded by Assessor"
4. Returns MOVUploadResponse with stored path and MOV entity

The assessor must have permission to review responses in the same governance
area as the assessment response's indicator. Existing JSON-based BLGU MOV
endpoints remain unchanged.

Args:
    response_id: The ID of the assessment response
    file: The file to upload (multipart/form-data)
    filename: Optional custom filename (if not provided, uses file.filename)

Returns:
    MOVUploadResponse with success status, storage path, and MOV entity
 * @summary Upload Mov File For Assessor
 */
export const postAssessorAssessmentResponses$ResponseIdMovsUpload = (
    responseId: number,
    bodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost: BodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost.file)
if(bodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost.filename !== undefined && bodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost.filename !== null) {
 formData.append(`filename`, bodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost.filename)
 }

      return mutator<MOVUploadResponse>(
      {url: `/api/v1/assessor/assessment-responses/${responseId}/movs/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getPostAssessorAssessmentResponsesResponseIdMovsUploadMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovsUpload>>, TError,{responseId: number;data: BodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovsUpload>>, TError,{responseId: number;data: BodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost}, TContext> => {

const mutationKey = ['postAssessorAssessmentResponsesResponseIdMovsUpload'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovsUpload>>, {responseId: number;data: BodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost}> = (props) => {
          const {responseId,data} = props ?? {};

          return  postAssessorAssessmentResponses$ResponseIdMovsUpload(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentResponsesResponseIdMovsUploadMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovsUpload>>>
    export type PostAssessorAssessmentResponsesResponseIdMovsUploadMutationBody = BodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost
    export type PostAssessorAssessmentResponsesResponseIdMovsUploadMutationError = HTTPValidationError

    /**
 * @summary Upload Mov File For Assessor
 */
export const usePostAssessorAssessmentResponsesResponseIdMovsUpload = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovsUpload>>, TError,{responseId: number;data: BodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovsUpload>>,
        TError,
        {responseId: number;data: BodyUploadMovFileForAssessorApiV1AssessorAssessmentResponsesResponseIdMovsUploadPost},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentResponsesResponseIdMovsUploadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get detailed assessment data for assessor review.

Returns full assessment details including:
- Assessment metadata and status
- BLGU user information and barangay details
- All responses with indicators and technical notes
- MOVs (Means of Verification) for each response
- Feedback comments from assessors

The assessor must have permission to view assessments in their
governance area. Technical notes are included for each indicator
to provide guidance during the review process.
 * @summary Get Assessment Details
 */
export const getAssessorAssessments$AssessmentId = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentDetailsResponse>(
      {url: `/api/v1/assessor/assessments/${assessmentId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAssessorAssessmentsAssessmentIdQueryKey = (assessmentId?: number,) => {
    return [
    `/api/v1/assessor/assessments/${assessmentId}`
    ] as const;
    }

    
export const getGetAssessorAssessmentsAssessmentIdQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError = HTTPValidationError>(assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorAssessmentsAssessmentIdQueryKey(assessmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>> = ({ signal }) => getAssessorAssessments$AssessmentId(assessmentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assessmentId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorAssessmentsAssessmentIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>>
export type GetAssessorAssessmentsAssessmentIdQueryError = HTTPValidationError


/**
 * @summary Get Assessment Details
 */

export function useGetAssessorAssessmentsAssessmentId<TData = Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError = HTTPValidationError>(
 assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorAssessmentsAssessmentIdQueryOptions(assessmentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Send assessment back to BLGU user for rework.

Changes the assessment status to 'Needs Rework' and triggers a notification
to the BLGU user. This endpoint fails with a 403 error if the assessment's
rework_count is not 0 (meaning it has already been sent for rework).

The assessor must have permission to review assessments in their governance area.
 * @summary Send Assessment For Rework
 */
export const postAssessorAssessments$AssessmentIdRework = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<unknown>(
      {url: `/api/v1/assessor/assessments/${assessmentId}/rework`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessorAssessmentsAssessmentIdReworkMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessorAssessmentsAssessmentIdRework'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessorAssessments$AssessmentIdRework(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentsAssessmentIdReworkMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>>
    
    export type PostAssessorAssessmentsAssessmentIdReworkMutationError = HTTPValidationError

    /**
 * @summary Send Assessment For Rework
 */
export const usePostAssessorAssessmentsAssessmentIdRework = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentsAssessmentIdReworkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Submit assessment for calibration (Validators only).

After workflow restructuring: Validators are system-wide.
Calibration sends the assessment back to BLGU for corrections on flagged indicators.
Only 1 calibration round is allowed per assessment.

Requirements:
- User must be a Validator (system-wide role after restructuring)
- Assessment must be in AWAITING_FINAL_VALIDATION status
- At least one indicator must have feedback (comments or MOV annotations)
- Calibration round must not have been used already

The validator must have permission to review assessments (system-wide access).
 * @summary Submit For Calibration
 */
export const postAssessorAssessments$AssessmentIdCalibrate = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<unknown>(
      {url: `/api/v1/assessor/assessments/${assessmentId}/calibrate`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessorAssessmentsAssessmentIdCalibrateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdCalibrate>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdCalibrate>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessorAssessmentsAssessmentIdCalibrate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdCalibrate>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessorAssessments$AssessmentIdCalibrate(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentsAssessmentIdCalibrateMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdCalibrate>>>
    
    export type PostAssessorAssessmentsAssessmentIdCalibrateMutationError = HTTPValidationError

    /**
 * @summary Submit For Calibration
 */
export const usePostAssessorAssessmentsAssessmentIdCalibrate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdCalibrate>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdCalibrate>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentsAssessmentIdCalibrateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Finalize assessment validation, permanently locking it.

Changes the assessment status to 'Validated', permanently locking the assessment
from further edits by either the BLGU or the Assessor. This action can only be
performed if all assessment responses have been reviewed (have a validation status).

The assessor must have permission to review assessments in their governance area.
 * @summary Finalize Assessment
 */
export const postAssessorAssessments$AssessmentIdFinalize = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<unknown>(
      {url: `/api/v1/assessor/assessments/${assessmentId}/finalize`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessorAssessmentsAssessmentIdFinalizeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessorAssessmentsAssessmentIdFinalize'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessorAssessments$AssessmentIdFinalize(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentsAssessmentIdFinalizeMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>>
    
    export type PostAssessorAssessmentsAssessmentIdFinalizeMutationError = HTTPValidationError

    /**
 * @summary Finalize Assessment
 */
export const usePostAssessorAssessmentsAssessmentIdFinalize = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentsAssessmentIdFinalizeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Manually trigger the classification algorithm for an assessment.

Applies the "3+1" SGLGB compliance rule to determine if the barangay
has passed or failed the assessment. This endpoint is primarily for
testing purposes - classification automatically runs during finalization.

The assessor must have permission to review assessments in their governance area.
 * @summary Classify Assessment
 */
export const postAssessorAssessments$AssessmentIdClassify = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<unknown>(
      {url: `/api/v1/assessor/assessments/${assessmentId}/classify`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessorAssessmentsAssessmentIdClassifyMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdClassify>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdClassify>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessorAssessmentsAssessmentIdClassify'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdClassify>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessorAssessments$AssessmentIdClassify(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentsAssessmentIdClassifyMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdClassify>>>
    
    export type PostAssessorAssessmentsAssessmentIdClassifyMutationError = HTTPValidationError

    /**
 * @summary Classify Assessment
 */
export const usePostAssessorAssessmentsAssessmentIdClassify = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdClassify>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdClassify>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentsAssessmentIdClassifyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get analytics data for the assessor's governance area.

Returns comprehensive analytics including:
- Overview: Performance metrics with totals, pass/fail counts, pass rate, and trend series
- Hotspots: Top underperforming indicators/areas with affected barangays and reasons
- Workflow: Counts/durations by status, average review times, and rework metrics

The analytics are calculated using existing assessment and response data
filtered by the assessor's governance area. This endpoint provides a minimal
implementation that can be extended as the UI grows.
 * @summary Get Assessor Analytics
 */
export const getAssessorAnalytics = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessorAnalyticsResponse>(
      {url: `/api/v1/assessor/analytics`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAssessorAnalyticsQueryKey = () => {
    return [
    `/api/v1/assessor/analytics`
    ] as const;
    }

    
export const getGetAssessorAnalyticsQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorAnalytics>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorAnalytics>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorAnalyticsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorAnalytics>>> = ({ signal }) => getAssessorAnalytics(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorAnalytics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorAnalyticsQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorAnalytics>>>
export type GetAssessorAnalyticsQueryError = unknown


/**
 * @summary Get Assessor Analytics
 */

export function useGetAssessorAnalytics<TData = Awaited<ReturnType<typeof getAssessorAnalytics>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorAnalytics>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorAnalyticsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get comprehensive dashboard data for assessors and validators.

**For VALIDATORS (system-wide access):**
- See ALL assessments across all 6 governance areas
- Aggregated compliance summary, area performance, failing indicators
- Allows validators to coordinate offline within their cluster

**For ASSESSORS (area-specific access):**
- See assessments filtered by their assigned governance area
- Area-specific analytics mirroring the MLGOO municipal overview

**Access:** VALIDATOR role OR ASSESSOR role with area assignment

Returns all dashboard sections in a single request:
- Compliance summary (pass/fail counts, rates)
- Governance area performance
- Top failing indicators
- Aggregated CapDev summary
- Barangay status list

Args:
    year: Optional year filter (e.g., 2024, 2025)
    include_draft: Include draft assessments in barangay list
    db: Database session
    current_user: Authenticated assessor user

Returns:
    Assessor dashboard with all sections filtered by governance area
 * @summary Get Validator Dashboard
 */
export const getAssessorDashboard = (
    params?: GetAssessorDashboardParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<MunicipalOverviewDashboard>(
      {url: `/api/v1/assessor/dashboard`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetAssessorDashboardQueryKey = (params?: GetAssessorDashboardParams,) => {
    return [
    `/api/v1/assessor/dashboard`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAssessorDashboardQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorDashboard>>, TError = HTTPValidationError>(params?: GetAssessorDashboardParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorDashboardQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorDashboard>>> = ({ signal }) => getAssessorDashboard(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorDashboard>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorDashboard>>>
export type GetAssessorDashboardQueryError = HTTPValidationError


/**
 * @summary Get Validator Dashboard
 */

export function useGetAssessorDashboard<TData = Awaited<ReturnType<typeof getAssessorDashboard>>, TError = HTTPValidationError>(
 params?: GetAssessorDashboardParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorDashboardQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get paginated review history for the current assessor/validator.

Returns COMPLETED assessments that the user has reviewed:
- Assessors: Assessments where reviewed_by matches the current user
- Validators: Completed assessments in their governance area

Each item includes summary counts (pass/fail/conditional indicators)
without loading full indicator details (for performance).
 * @summary Get Review History
 */
export const getAssessorHistory = (
    params?: GetAssessorHistoryParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<ReviewHistoryResponse>(
      {url: `/api/v1/assessor/history`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetAssessorHistoryQueryKey = (params?: GetAssessorHistoryParams,) => {
    return [
    `/api/v1/assessor/history`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAssessorHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorHistory>>, TError = HTTPValidationError>(params?: GetAssessorHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorHistory>>> = ({ signal }) => getAssessorHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorHistory>>>
export type GetAssessorHistoryQueryError = HTTPValidationError


/**
 * @summary Get Review History
 */

export function useGetAssessorHistory<TData = Awaited<ReturnType<typeof getAssessorHistory>>, TError = HTTPValidationError>(
 params?: GetAssessorHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get detailed per-indicator decisions for a specific completed assessment.

Used when user expands a row to see inline indicator details including:
- Validation status (Pass/Fail/Conditional) per indicator
- Feedback comments given
- Calibration flags
- MOV counts

Access control:
- Assessors can only view assessments they reviewed (reviewed_by == user.id)
- Validators can view assessments in their governance area
 * @summary Get Review History Detail
 */
export const getAssessorHistory$AssessmentId = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<ReviewHistoryDetail>(
      {url: `/api/v1/assessor/history/${assessmentId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAssessorHistoryAssessmentIdQueryKey = (assessmentId?: number,) => {
    return [
    `/api/v1/assessor/history/${assessmentId}`
    ] as const;
    }

    
export const getGetAssessorHistoryAssessmentIdQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorHistory$AssessmentId>>, TError = HTTPValidationError>(assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorHistory$AssessmentId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorHistoryAssessmentIdQueryKey(assessmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorHistory$AssessmentId>>> = ({ signal }) => getAssessorHistory$AssessmentId(assessmentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assessmentId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorHistory$AssessmentId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorHistoryAssessmentIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorHistory$AssessmentId>>>
export type GetAssessorHistoryAssessmentIdQueryError = HTTPValidationError


/**
 * @summary Get Review History Detail
 */

export function useGetAssessorHistoryAssessmentId<TData = Awaited<ReturnType<typeof getAssessorHistory$AssessmentId>>, TError = HTTPValidationError>(
 assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorHistory$AssessmentId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorHistoryAssessmentIdQueryOptions(assessmentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new annotation on a MOV file.

Allows assessors to add highlights and comments on PDF and image MOV files.
Supports both single-line and multi-line text selections for PDFs, and
rectangle annotations for images.
 * @summary Create Annotation
 */
export const postAssessorMovs$MovFileIdAnnotations = (
    movFileId: number,
    annotationCreate: AnnotationCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AnnotationResponse>(
      {url: `/api/v1/assessor/movs/${movFileId}/annotations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: annotationCreate, signal
    },
      options);
    }
  


export const getPostAssessorMovsMovFileIdAnnotationsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorMovs$MovFileIdAnnotations>>, TError,{movFileId: number;data: AnnotationCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorMovs$MovFileIdAnnotations>>, TError,{movFileId: number;data: AnnotationCreate}, TContext> => {

const mutationKey = ['postAssessorMovsMovFileIdAnnotations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorMovs$MovFileIdAnnotations>>, {movFileId: number;data: AnnotationCreate}> = (props) => {
          const {movFileId,data} = props ?? {};

          return  postAssessorMovs$MovFileIdAnnotations(movFileId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorMovsMovFileIdAnnotationsMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorMovs$MovFileIdAnnotations>>>
    export type PostAssessorMovsMovFileIdAnnotationsMutationBody = AnnotationCreate
    export type PostAssessorMovsMovFileIdAnnotationsMutationError = HTTPValidationError

    /**
 * @summary Create Annotation
 */
export const usePostAssessorMovsMovFileIdAnnotations = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorMovs$MovFileIdAnnotations>>, TError,{movFileId: number;data: AnnotationCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorMovs$MovFileIdAnnotations>>,
        TError,
        {movFileId: number;data: AnnotationCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessorMovsMovFileIdAnnotationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get all annotations for a specific MOV file.

Returns all annotations (highlights and comments) that the assessor has
made on the specified MOV file, ordered by creation time.
 * @summary Get Annotations For Mov
 */
export const getAssessorMovs$MovFileIdAnnotations = (
    movFileId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AnnotationResponse[]>(
      {url: `/api/v1/assessor/movs/${movFileId}/annotations`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAssessorMovsMovFileIdAnnotationsQueryKey = (movFileId?: number,) => {
    return [
    `/api/v1/assessor/movs/${movFileId}/annotations`
    ] as const;
    }

    
export const getGetAssessorMovsMovFileIdAnnotationsQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorMovs$MovFileIdAnnotations>>, TError = HTTPValidationError>(movFileId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdAnnotations>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorMovsMovFileIdAnnotationsQueryKey(movFileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdAnnotations>>> = ({ signal }) => getAssessorMovs$MovFileIdAnnotations(movFileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(movFileId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdAnnotations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorMovsMovFileIdAnnotationsQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdAnnotations>>>
export type GetAssessorMovsMovFileIdAnnotationsQueryError = HTTPValidationError


/**
 * @summary Get Annotations For Mov
 */

export function useGetAssessorMovsMovFileIdAnnotations<TData = Awaited<ReturnType<typeof getAssessorMovs$MovFileIdAnnotations>>, TError = HTTPValidationError>(
 movFileId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdAnnotations>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorMovsMovFileIdAnnotationsQueryOptions(movFileId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all annotations for all MOV files in an assessment.

Returns all annotations across all MOV files in the assessment,
ordered by creation time.
 * @summary Get Annotations For Assessment
 */
export const getAssessorAssessments$AssessmentIdAnnotations = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AnnotationResponse[]>(
      {url: `/api/v1/assessor/assessments/${assessmentId}/annotations`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAssessorAssessmentsAssessmentIdAnnotationsQueryKey = (assessmentId?: number,) => {
    return [
    `/api/v1/assessor/assessments/${assessmentId}/annotations`
    ] as const;
    }

    
export const getGetAssessorAssessmentsAssessmentIdAnnotationsQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorAssessments$AssessmentIdAnnotations>>, TError = HTTPValidationError>(assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentIdAnnotations>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorAssessmentsAssessmentIdAnnotationsQueryKey(assessmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentIdAnnotations>>> = ({ signal }) => getAssessorAssessments$AssessmentIdAnnotations(assessmentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assessmentId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentIdAnnotations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorAssessmentsAssessmentIdAnnotationsQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentIdAnnotations>>>
export type GetAssessorAssessmentsAssessmentIdAnnotationsQueryError = HTTPValidationError


/**
 * @summary Get Annotations For Assessment
 */

export function useGetAssessorAssessmentsAssessmentIdAnnotations<TData = Awaited<ReturnType<typeof getAssessorAssessments$AssessmentIdAnnotations>>, TError = HTTPValidationError>(
 assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentIdAnnotations>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorAssessmentsAssessmentIdAnnotationsQueryOptions(assessmentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing annotation.

Allows the assessor to edit the comment text of their own annotations.
Assessors can only update annotations they created.
 * @summary Update Annotation
 */
export const patchAssessorAnnotations$AnnotationId = (
    annotationId: number,
    annotationUpdate: AnnotationUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<AnnotationResponse>(
      {url: `/api/v1/assessor/annotations/${annotationId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: annotationUpdate
    },
      options);
    }
  


export const getPatchAssessorAnnotationsAnnotationIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAssessorAnnotations$AnnotationId>>, TError,{annotationId: number;data: AnnotationUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof patchAssessorAnnotations$AnnotationId>>, TError,{annotationId: number;data: AnnotationUpdate}, TContext> => {

const mutationKey = ['patchAssessorAnnotationsAnnotationId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchAssessorAnnotations$AnnotationId>>, {annotationId: number;data: AnnotationUpdate}> = (props) => {
          const {annotationId,data} = props ?? {};

          return  patchAssessorAnnotations$AnnotationId(annotationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchAssessorAnnotationsAnnotationIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchAssessorAnnotations$AnnotationId>>>
    export type PatchAssessorAnnotationsAnnotationIdMutationBody = AnnotationUpdate
    export type PatchAssessorAnnotationsAnnotationIdMutationError = HTTPValidationError

    /**
 * @summary Update Annotation
 */
export const usePatchAssessorAnnotationsAnnotationId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAssessorAnnotations$AnnotationId>>, TError,{annotationId: number;data: AnnotationUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchAssessorAnnotations$AnnotationId>>,
        TError,
        {annotationId: number;data: AnnotationUpdate},
        TContext
      > => {

      const mutationOptions = getPatchAssessorAnnotationsAnnotationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Delete an annotation.

Removes the annotation from the MOV file. Assessors can only delete
annotations they created.
 * @summary Delete Annotation
 */
export const deleteAssessorAnnotations$AnnotationId = (
    annotationId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<unknown>(
      {url: `/api/v1/assessor/annotations/${annotationId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAssessorAnnotationsAnnotationIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessorAnnotations$AnnotationId>>, TError,{annotationId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssessorAnnotations$AnnotationId>>, TError,{annotationId: number}, TContext> => {

const mutationKey = ['deleteAssessorAnnotationsAnnotationId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssessorAnnotations$AnnotationId>>, {annotationId: number}> = (props) => {
          const {annotationId} = props ?? {};

          return  deleteAssessorAnnotations$AnnotationId(annotationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssessorAnnotationsAnnotationIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssessorAnnotations$AnnotationId>>>
    
    export type DeleteAssessorAnnotationsAnnotationIdMutationError = HTTPValidationError

    /**
 * @summary Delete Annotation
 */
export const useDeleteAssessorAnnotationsAnnotationId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessorAnnotations$AnnotationId>>, TError,{annotationId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssessorAnnotations$AnnotationId>>,
        TError,
        {annotationId: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssessorAnnotationsAnnotationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Update MOV notes and flag for a specific MOV file.

Assessors and validators maintain separate fields:
- Assessor: notes + rework flag
- Validator: notes + calibration flag

**Path Parameters:**
- mov_file_id: ID of the MOV file to update

**Request Body:**
- assessor_notes / flagged_for_rework (assessor fields)
- validator_notes / flagged_for_calibration (validator fields)

**Returns:** Updated MOV assessor feedback

**Raises:**
- 404: MOV file not found
- 403: User not authorized to update this MOV
 * @summary Update per-MOV assessor feedback
 */
export const patchAssessorMovs$MovFileIdFeedback = (
    movFileId: number,
    mOVAssessorFeedbackUpdate: MOVAssessorFeedbackUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<MOVAssessorFeedbackResponse>(
      {url: `/api/v1/assessor/movs/${movFileId}/feedback`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: mOVAssessorFeedbackUpdate
    },
      options);
    }
  


export const getPatchAssessorMovsMovFileIdFeedbackMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAssessorMovs$MovFileIdFeedback>>, TError,{movFileId: number;data: MOVAssessorFeedbackUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof patchAssessorMovs$MovFileIdFeedback>>, TError,{movFileId: number;data: MOVAssessorFeedbackUpdate}, TContext> => {

const mutationKey = ['patchAssessorMovsMovFileIdFeedback'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchAssessorMovs$MovFileIdFeedback>>, {movFileId: number;data: MOVAssessorFeedbackUpdate}> = (props) => {
          const {movFileId,data} = props ?? {};

          return  patchAssessorMovs$MovFileIdFeedback(movFileId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchAssessorMovsMovFileIdFeedbackMutationResult = NonNullable<Awaited<ReturnType<typeof patchAssessorMovs$MovFileIdFeedback>>>
    export type PatchAssessorMovsMovFileIdFeedbackMutationBody = MOVAssessorFeedbackUpdate
    export type PatchAssessorMovsMovFileIdFeedbackMutationError = HTTPValidationError

    /**
 * @summary Update per-MOV assessor feedback
 */
export const usePatchAssessorMovsMovFileIdFeedback = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAssessorMovs$MovFileIdFeedback>>, TError,{movFileId: number;data: MOVAssessorFeedbackUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchAssessorMovs$MovFileIdFeedback>>,
        TError,
        {movFileId: number;data: MOVAssessorFeedbackUpdate},
        TContext
      > => {

      const mutationOptions = getPatchAssessorMovsMovFileIdFeedbackMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get MOV feedback for a specific MOV file.

Returns assessor and validator note/flag fields for the specified MOV file.

**Path Parameters:**
- mov_file_id: ID of the MOV file

**Returns:** MOV assessor feedback data

**Raises:**
- 404: MOV file not found
 * @summary Get per-MOV assessor feedback
 */
export const getAssessorMovs$MovFileIdFeedback = (
    movFileId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<MOVAssessorFeedbackResponse>(
      {url: `/api/v1/assessor/movs/${movFileId}/feedback`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAssessorMovsMovFileIdFeedbackQueryKey = (movFileId?: number,) => {
    return [
    `/api/v1/assessor/movs/${movFileId}/feedback`
    ] as const;
    }

    
export const getGetAssessorMovsMovFileIdFeedbackQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorMovs$MovFileIdFeedback>>, TError = HTTPValidationError>(movFileId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdFeedback>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorMovsMovFileIdFeedbackQueryKey(movFileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdFeedback>>> = ({ signal }) => getAssessorMovs$MovFileIdFeedback(movFileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(movFileId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdFeedback>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorMovsMovFileIdFeedbackQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdFeedback>>>
export type GetAssessorMovsMovFileIdFeedbackQueryError = HTTPValidationError


/**
 * @summary Get per-MOV assessor feedback
 */

export function useGetAssessorMovsMovFileIdFeedback<TData = Awaited<ReturnType<typeof getAssessorMovs$MovFileIdFeedback>>, TError = HTTPValidationError>(
 movFileId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorMovs$MovFileIdFeedback>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorMovsMovFileIdFeedbackQueryOptions(movFileId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Assessor approves their assigned governance area.

After workflow restructuring, assessors are area-specific (6 users for 6 areas).
Each assessor can only approve their assigned governance area.

When all 6 areas are approved, the assessment moves to AWAITING_FINAL_VALIDATION.

**Path Parameters:**
- assessment_id: ID of the assessment
- governance_area_id: ID of the governance area (1-6)

**Returns:** Success status, new area status, and whether all areas are approved

**Raises:**
- 403: User not authorized for this governance area
- 404: Assessment not found
- 400: Area cannot be approved (wrong status)
 * @summary Approve governance area
 */
export const postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdApprove = (
    assessmentId: number,
    governanceAreaId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<unknown>(
      {url: `/api/v1/assessor/assessments/${assessmentId}/areas/${governanceAreaId}/approve`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdApproveMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdApprove>>, TError,{assessmentId: number;governanceAreaId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdApprove>>, TError,{assessmentId: number;governanceAreaId: number}, TContext> => {

const mutationKey = ['postAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdApprove'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdApprove>>, {assessmentId: number;governanceAreaId: number}> = (props) => {
          const {assessmentId,governanceAreaId} = props ?? {};

          return  postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdApprove(assessmentId,governanceAreaId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdApproveMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdApprove>>>
    
    export type PostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdApproveMutationError = HTTPValidationError

    /**
 * @summary Approve governance area
 */
export const usePostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdApprove = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdApprove>>, TError,{assessmentId: number;governanceAreaId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdApprove>>,
        TError,
        {assessmentId: number;governanceAreaId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdApproveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Assessor sends their assigned governance area back for rework.

After workflow restructuring, assessors are area-specific (6 users for 6 areas).
Each assessor can only request rework for their assigned governance area.

All 6 assessors' rework requests are compiled into a single rework round.
The BLGU sees all rework requests together and fixes everything in one pass.

**Path Parameters:**
- assessment_id: ID of the assessment
- governance_area_id: ID of the governance area (1-6)

**Form Data:**
- comments: Rework comments explaining what needs to be fixed

**Returns:** Success status and new area status

**Raises:**
- 403: User not authorized for this governance area
- 404: Assessment not found
- 400: Rework not allowed (wrong status or rework round already used)
 * @summary Send governance area for rework
 */
export const postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdRework = (
    assessmentId: number,
    governanceAreaId: number,
    bodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost: BodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`comments`, bodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost.comments)

      return mutator<unknown>(
      {url: `/api/v1/assessor/assessments/${assessmentId}/areas/${governanceAreaId}/rework`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      options);
    }
  


export const getPostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdRework>>, TError,{assessmentId: number;governanceAreaId: number;data: BodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdRework>>, TError,{assessmentId: number;governanceAreaId: number;data: BodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost}, TContext> => {

const mutationKey = ['postAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdRework'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdRework>>, {assessmentId: number;governanceAreaId: number;data: BodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost}> = (props) => {
          const {assessmentId,governanceAreaId,data} = props ?? {};

          return  postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdRework(assessmentId,governanceAreaId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdRework>>>
    export type PostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkMutationBody = BodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost
    export type PostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkMutationError = HTTPValidationError

    /**
 * @summary Send governance area for rework
 */
export const usePostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdRework = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdRework>>, TError,{assessmentId: number;governanceAreaId: number;data: BodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdAreas$GovernanceAreaIdRework>>,
        TError,
        {assessmentId: number;governanceAreaId: number;data: BodySendAreaForReworkApiV1AssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkPost},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentsAssessmentIdAreasGovernanceAreaIdReworkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    