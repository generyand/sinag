/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyTestCalculationApiV1IndicatorsTestCalculationPost,
  CalculationSchema,
  FormSchema,
  FormSchemaResponse,
  GetIndicatorsCodeIndicatorCodeParams,
  GetIndicatorsCodeIndicatorCodeTreeParams,
  GetIndicatorsIndicatorIdParams,
  GetIndicatorsParams,
  GetIndicatorsTreeGovernanceAreaId200Item,
  GetIndicatorsTreeGovernanceAreaIdParams,
  HTTPValidationError,
  IndicatorCreate,
  IndicatorHistoryResponse,
  IndicatorResponse,
  IndicatorTreeResponse,
  IndicatorUpdate,
  PostIndicatorsTestCalculation200,
  PostIndicatorsValidateCalculationSchema200,
  PostIndicatorsValidateFormSchema200,
  SimplifiedIndicatorResponse
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Create a new indicator with version 1.

**Permissions**: MLGOO_DILG only

**Request Body**:
- name: Indicator name (min 3 characters)
- description: Optional description
- governance_area_id: ID of governance area
- parent_id: Optional parent indicator ID (for hierarchical structure)
- is_active: Active status (default: True)
- is_profiling_only: Profiling-only flag (default: False)
- is_auto_calculable: Auto-calculable Pass/Fail flag (default: False)
- form_schema: Optional form schema (JSON)
- calculation_schema: Optional calculation schema (JSON)
- remark_schema: Optional remark schema (JSON)
- technical_notes_text: Optional technical notes

**Returns**: Created indicator with version 1
 * @summary Create a new indicator
 */
export const postIndicators = (
    indicatorCreate: IndicatorCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `/api/v1/indicators/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: indicatorCreate, signal
    },
      options);
    }
  


export const getPostIndicatorsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext> => {

const mutationKey = ['postIndicators'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicators>>, {data: IndicatorCreate}> = (props) => {
          const {data} = props ?? {};

          return  postIndicators(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicators>>>
    export type PostIndicatorsMutationBody = IndicatorCreate
    export type PostIndicatorsMutationError = HTTPValidationError

    /**
 * @summary Create a new indicator
 */
export const usePostIndicators = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicators>>,
        TError,
        {data: IndicatorCreate},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * List indicators with optional filtering.

**Permissions**: All authenticated users

**Query Parameters**:
- governance_area_id: Filter by governance area (optional)
- is_active: Filter by active status (optional)
- skip: Pagination offset (default: 0)
- limit: Max records (default: 100, max: 1000)
- year: Assessment year for placeholder resolution (optional, uses active year if not provided)

**Returns**: List of indicators matching filters with resolved year placeholders
 * @summary List all indicators
 */
export const getIndicators = (
    params?: GetIndicatorsParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse[]>(
      {url: `/api/v1/indicators/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetIndicatorsQueryKey = (params?: GetIndicatorsParams,) => {
    return [
    `/api/v1/indicators/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetIndicatorsQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators>>, TError = HTTPValidationError>(params?: GetIndicatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators>>> = ({ signal }) => getIndicators(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators>>>
export type GetIndicatorsQueryError = HTTPValidationError


/**
 * @summary List all indicators
 */

export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = HTTPValidationError>(
 params?: GetIndicatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Validate a form schema without saving it.

**Permissions**: MLGOO_DILG only

**Request Body**:
- form_schema: FormSchema object with fields to validate

**Returns**:
- `{"valid": true}` if the schema is valid
- `{"valid": false, "errors": [...]}` if validation fails with detailed error messages

**Validation Checks**:
- Field IDs are unique
- No circular references in conditional logic
- Conditional MOV references point to existing fields
- Checkbox/Radio fields have at least one option
- Fields list is not empty

**Status Codes**:
- 200: Schema is valid
- 400: Schema is invalid (returns error details)
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not MLGOO_DILG role)
 * @summary Validate a form schema
 */
export const postIndicatorsValidateFormSchema = (
    formSchema: FormSchema,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostIndicatorsValidateFormSchema200>(
      {url: `/api/v1/indicators/validate-form-schema`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: formSchema, signal
    },
      options);
    }
  


export const getPostIndicatorsValidateFormSchemaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchema}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchema}, TContext> => {

const mutationKey = ['postIndicatorsValidateFormSchema'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, {data: FormSchema}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsValidateFormSchema(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsValidateFormSchemaMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>>
    export type PostIndicatorsValidateFormSchemaMutationBody = FormSchema
    export type PostIndicatorsValidateFormSchemaMutationError = HTTPValidationError

    /**
 * @summary Validate a form schema
 */
export const usePostIndicatorsValidateFormSchema = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchema}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>,
        TError,
        {data: FormSchema},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsValidateFormSchemaMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Validate a calculation schema without saving it.

**Permissions**: MLGOO_DILG only

**Request Body**:
- calculation_schema: CalculationSchema object with condition groups and rules

**Returns**:
- `{"valid": true}` if the schema is valid
- `{"valid": false, "errors": [...]}` if validation fails

**Validation Checks**:
- All rule types are valid and properly structured
- Field references are present (basic structure validation)
- Nested conditions are properly formed
- Operators are valid for each rule type

**Status Codes**:
- 200: Schema is valid
- 400: Schema is invalid (returns error details)
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not MLGOO_DILG role)

**Note**: This endpoint only validates the schema structure.
To test the schema with actual data, use the `/test-calculation` endpoint.
 * @summary Validate a calculation schema
 */
export const postIndicatorsValidateCalculationSchema = (
    calculationSchema: CalculationSchema,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostIndicatorsValidateCalculationSchema200>(
      {url: `/api/v1/indicators/validate-calculation-schema`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: calculationSchema, signal
    },
      options);
    }
  


export const getPostIndicatorsValidateCalculationSchemaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>, TError,{data: CalculationSchema}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>, TError,{data: CalculationSchema}, TContext> => {

const mutationKey = ['postIndicatorsValidateCalculationSchema'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>, {data: CalculationSchema}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsValidateCalculationSchema(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsValidateCalculationSchemaMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>>
    export type PostIndicatorsValidateCalculationSchemaMutationBody = CalculationSchema
    export type PostIndicatorsValidateCalculationSchemaMutationError = HTTPValidationError

    /**
 * @summary Validate a calculation schema
 */
export const usePostIndicatorsValidateCalculationSchema = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>, TError,{data: CalculationSchema}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>,
        TError,
        {data: CalculationSchema},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsValidateCalculationSchemaMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Test a calculation schema with sample assessment data.

**Permissions**: MLGOO_DILG only

**Request Body**:
- calculation_schema: CalculationSchema to evaluate
- assessment_data: Dictionary of field_id -> value pairs
  Example: {"completion_rate": 85, "required_documents": ["doc1", "doc2", "doc3"]}

**Returns**:
```json
{
  "result": "Pass" | "Fail",
  "evaluation_result": true | false,
  "explanation": "Detailed explanation of evaluation",
  "output_status_on_pass": "Pass",
  "output_status_on_fail": "Fail"
}
```

**Status Codes**:
- 200: Calculation completed successfully
- 400: Invalid schema or data (e.g., field not found, type mismatch)
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not MLGOO_DILG role)

**Error Examples**:
- Field not found: `{"detail": "Field 'completion_rate' not found in assessment data. Available fields: ['other_field']"}`
- Type mismatch: `{"detail": "Field 'count' expected list for checkbox count, got str"}`

**Example Usage**:
```json
{
  "calculation_schema": {
    "condition_groups": [
      {
        "operator": "AND",
        "rules": [
          {
            "rule_type": "PERCENTAGE_THRESHOLD",
            "field_id": "completion_rate",
            "operator": ">=",
            "threshold": 75.0
          }
        ]
      }
    ],
    "output_status_on_pass": "Pass",
    "output_status_on_fail": "Fail"
  },
  "assessment_data": {
    "completion_rate": 85
  }
}
```
 * @summary Test a calculation schema with sample data
 */
export const postIndicatorsTestCalculation = (
    bodyTestCalculationApiV1IndicatorsTestCalculationPost: BodyTestCalculationApiV1IndicatorsTestCalculationPost,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostIndicatorsTestCalculation200>(
      {url: `/api/v1/indicators/test-calculation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyTestCalculationApiV1IndicatorsTestCalculationPost, signal
    },
      options);
    }
  


export const getPostIndicatorsTestCalculationMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>, TError,{data: BodyTestCalculationApiV1IndicatorsTestCalculationPost}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>, TError,{data: BodyTestCalculationApiV1IndicatorsTestCalculationPost}, TContext> => {

const mutationKey = ['postIndicatorsTestCalculation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>, {data: BodyTestCalculationApiV1IndicatorsTestCalculationPost}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsTestCalculation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsTestCalculationMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>>
    export type PostIndicatorsTestCalculationMutationBody = BodyTestCalculationApiV1IndicatorsTestCalculationPost
    export type PostIndicatorsTestCalculationMutationError = HTTPValidationError

    /**
 * @summary Test a calculation schema with sample data
 */
export const usePostIndicatorsTestCalculation = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>, TError,{data: BodyTestCalculationApiV1IndicatorsTestCalculationPost}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsTestCalculation>>,
        TError,
        {data: BodyTestCalculationApiV1IndicatorsTestCalculationPost},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsTestCalculationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get a specific indicator by ID.

**Permissions**: All authenticated users

**Path Parameters**:
- indicator_id: ID of the indicator

**Query Parameters**:
- year: Assessment year for placeholder resolution (optional, uses active year if not provided)

**Returns**: Indicator details including current version with resolved year placeholders

**Raises**:
- 404: Indicator not found
 * @summary Get indicator by ID
 */
export const getIndicators$IndicatorId = (
    indicatorId: number,
    params?: GetIndicatorsIndicatorIdParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `/api/v1/indicators/${indicatorId}`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetIndicatorsIndicatorIdQueryKey = (indicatorId?: number,
    params?: GetIndicatorsIndicatorIdParams,) => {
    return [
    `/api/v1/indicators/${indicatorId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetIndicatorsIndicatorIdQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError = HTTPValidationError>(indicatorId: number,
    params?: GetIndicatorsIndicatorIdParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorIdQueryKey(indicatorId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators$IndicatorId>>> = ({ signal }) => getIndicators$IndicatorId(indicatorId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators$IndicatorId>>>
export type GetIndicatorsIndicatorIdQueryError = HTTPValidationError


/**
 * @summary Get indicator by ID
 */

export function useGetIndicatorsIndicatorId<TData = Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError = HTTPValidationError>(
 indicatorId: number,
    params?: GetIndicatorsIndicatorIdParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorIdQueryOptions(indicatorId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an indicator.

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- indicator_id: ID of the indicator to update

**Request Body**: All fields optional for partial updates
- name: Indicator name (min 3 characters)
- description: Description
- governance_area_id: ID of governance area
- parent_id: Parent indicator ID
- is_active: Active status
- is_profiling_only: Profiling-only flag
- is_auto_calculable: Auto-calculable Pass/Fail flag
- form_schema: Form schema (JSON)
- calculation_schema: Calculation schema (JSON)
- remark_schema: Remark schema (JSON)
- technical_notes_text: Technical notes

**Versioning Logic**:
- If any schema field (form_schema, calculation_schema, remark_schema) changes,
  the current version is archived to indicators_history and version is incremented
- Metadata changes (name, description, etc.) do not trigger versioning

**Returns**: Updated indicator

**Raises**:
- 404: Indicator not found
- 400: Circular parent reference detected
- 400: Invalid governance_area_id
 * @summary Update an indicator
 */
export const putIndicators$IndicatorId = (
    indicatorId: number,
    indicatorUpdate: IndicatorUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `/api/v1/indicators/${indicatorId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: indicatorUpdate
    },
      options);
    }
  


export const getPutIndicatorsIndicatorIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext> => {

const mutationKey = ['putIndicatorsIndicatorId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, {indicatorId: number;data: IndicatorUpdate}> = (props) => {
          const {indicatorId,data} = props ?? {};

          return  putIndicators$IndicatorId(indicatorId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIndicatorsIndicatorIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIndicators$IndicatorId>>>
    export type PutIndicatorsIndicatorIdMutationBody = IndicatorUpdate
    export type PutIndicatorsIndicatorIdMutationError = HTTPValidationError

    /**
 * @summary Update an indicator
 */
export const usePutIndicatorsIndicatorId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putIndicators$IndicatorId>>,
        TError,
        {indicatorId: number;data: IndicatorUpdate},
        TContext
      > => {

      const mutationOptions = getPutIndicatorsIndicatorIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Deactivate an indicator (soft delete).

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- indicator_id: ID of the indicator to deactivate

**Returns**: Deactivated indicator (is_active=False)

**Raises**:
- 404: Indicator not found
- 400: Cannot deactivate indicator with active child indicators
 * @summary Deactivate an indicator
 */
export const deleteIndicators$IndicatorId = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `/api/v1/indicators/${indicatorId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIndicatorsIndicatorIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext> => {

const mutationKey = ['deleteIndicatorsIndicatorId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, {indicatorId: number}> = (props) => {
          const {indicatorId} = props ?? {};

          return  deleteIndicators$IndicatorId(indicatorId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIndicatorsIndicatorIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>>
    
    export type DeleteIndicatorsIndicatorIdMutationError = HTTPValidationError

    /**
 * @summary Deactivate an indicator
 */
export const useDeleteIndicatorsIndicatorId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>,
        TError,
        {indicatorId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIndicatorsIndicatorIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get version history for an indicator.

**Permissions**: All authenticated users

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: List of archived versions ordered by version DESC (newest first)

**Raises**:
- 404: Indicator not found
 * @summary Get indicator version history
 */
export const getIndicators$IndicatorIdHistory = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorHistoryResponse[]>(
      {url: `/api/v1/indicators/${indicatorId}/history`, method: 'GET', signal
    },
      options);
    }
  



export const getGetIndicatorsIndicatorIdHistoryQueryKey = (indicatorId?: number,) => {
    return [
    `/api/v1/indicators/${indicatorId}/history`
    ] as const;
    }

    
export const getGetIndicatorsIndicatorIdHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorIdHistoryQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>> = ({ signal }) => getIndicators$IndicatorIdHistory(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorIdHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>>
export type GetIndicatorsIndicatorIdHistoryQueryError = HTTPValidationError


/**
 * @summary Get indicator version history
 */

export function useGetIndicatorsIndicatorIdHistory<TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorIdHistoryQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get form schema for a specific indicator.

**Permissions**: All authenticated users
- BLGU users: Can access all indicators (all barangays complete all governance areas)
- Assessors and validators: Can access all indicators

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: Form schema with metadata (title, description, governance area)

**Raises**:
- 404: Indicator not found
 * @summary Get form schema for an indicator
 */
export const getIndicators$IndicatorIdFormSchema = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<FormSchemaResponse>(
      {url: `/api/v1/indicators/${indicatorId}/form-schema`, method: 'GET', signal
    },
      options);
    }
  



export const getGetIndicatorsIndicatorIdFormSchemaQueryKey = (indicatorId?: number,) => {
    return [
    `/api/v1/indicators/${indicatorId}/form-schema`
    ] as const;
    }

    
export const getGetIndicatorsIndicatorIdFormSchemaQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorIdFormSchemaQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>> = ({ signal }) => getIndicators$IndicatorIdFormSchema(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorIdFormSchemaQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>>
export type GetIndicatorsIndicatorIdFormSchemaQueryError = HTTPValidationError


/**
 * @summary Get form schema for an indicator
 */

export function useGetIndicatorsIndicatorIdFormSchema<TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorIdFormSchemaQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get hierarchical tree structure of indicators for a governance area.

**Permissions**: All authenticated users

**Path Parameters**:
- governance_area_id: Governance area ID

**Query Parameters**:
- year: Optional assessment year for placeholder resolution.
        If viewing a historical assessment, pass the assessment's year.
        If not provided, uses the currently active year.
        Example: year=2024 will resolve {CURRENT_YEAR} as "2024"

**Returns**: List of root indicator nodes with nested children

**Tree Structure**:
```json
[
    {
        "id": 1,
        "name": "Root Indicator",
        "indicator_code": "1.1",
        "sort_order": 0,
        "selection_mode": "none",
        "parent_id": null,
        "children": [
            {
                "id": 2,
                "name": "Child Indicator",
                "indicator_code": "1.1.1",
                "sort_order": 0,
                "parent_id": 1,
                "children": []
            }
        ]
    }
]
```

**Features**:
- Hierarchical parent-child relationships
- Automatic code generation (1.1, 1.1.1, etc.)
- MOV checklist items included
- Form, calculation, and remark schemas included
- Dynamic year placeholder resolution ({CURRENT_YEAR}, {PREVIOUS_YEAR}, etc.)

**Raises**:
- 404: Governance area not found
 * @summary Get indicator tree structure
 */
export const getIndicatorsTree$GovernanceAreaId = (
    governanceAreaId: number,
    params?: GetIndicatorsTreeGovernanceAreaIdParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetIndicatorsTreeGovernanceAreaId200Item[]>(
      {url: `/api/v1/indicators/tree/${governanceAreaId}`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetIndicatorsTreeGovernanceAreaIdQueryKey = (governanceAreaId?: number,
    params?: GetIndicatorsTreeGovernanceAreaIdParams,) => {
    return [
    `/api/v1/indicators/tree/${governanceAreaId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetIndicatorsTreeGovernanceAreaIdQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError = HTTPValidationError>(governanceAreaId: number,
    params?: GetIndicatorsTreeGovernanceAreaIdParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsTreeGovernanceAreaIdQueryKey(governanceAreaId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>> = ({ signal }) => getIndicatorsTree$GovernanceAreaId(governanceAreaId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(governanceAreaId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsTreeGovernanceAreaIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>>
export type GetIndicatorsTreeGovernanceAreaIdQueryError = HTTPValidationError


/**
 * @summary Get indicator tree structure
 */

export function useGetIndicatorsTreeGovernanceAreaId<TData = Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError = HTTPValidationError>(
 governanceAreaId: number,
    params?: GetIndicatorsTreeGovernanceAreaIdParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsTreeGovernanceAreaIdQueryOptions(governanceAreaId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Recalculate indicator codes for a governance area after reordering.

Automatically generates hierarchical codes like "1.1", "1.1.1", "1.2"
based on tree structure and sort_order.

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- governance_area_id: Governance area ID

**Returns**: List of updated indicators with new codes

**Code Generation Logic**:
- Root nodes: "1", "2", "3", ...
- First-level children: "1.1", "1.2", "1.3", ...
- Second-level children: "1.1.1", "1.1.2", ...
- Sort order determines numbering within siblings

**Example**:
Before reorder:
- Indicator A (code: "1.1", sort_order: 1)
- Indicator B (code: "1.2", sort_order: 0)

After recalculate (sorted by sort_order):
- Indicator B (code: "1.1", sort_order: 0)
- Indicator A (code: "1.2", sort_order: 1)

**Raises**:
- 404: Governance area not found
 * @summary Recalculate indicator codes
 */
export const postIndicatorsRecalculateCodes$GovernanceAreaId = (
    governanceAreaId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse[]>(
      {url: `/api/v1/indicators/recalculate-codes/${governanceAreaId}`, method: 'POST', signal
    },
      options);
    }
  


export const getPostIndicatorsRecalculateCodesGovernanceAreaIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>, TError,{governanceAreaId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>, TError,{governanceAreaId: number}, TContext> => {

const mutationKey = ['postIndicatorsRecalculateCodesGovernanceAreaId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>, {governanceAreaId: number}> = (props) => {
          const {governanceAreaId} = props ?? {};

          return  postIndicatorsRecalculateCodes$GovernanceAreaId(governanceAreaId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsRecalculateCodesGovernanceAreaIdMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>>
    
    export type PostIndicatorsRecalculateCodesGovernanceAreaIdMutationError = HTTPValidationError

    /**
 * @summary Recalculate indicator codes
 */
export const usePostIndicatorsRecalculateCodesGovernanceAreaId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>, TError,{governanceAreaId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>,
        TError,
        {governanceAreaId: number},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsRecalculateCodesGovernanceAreaIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get a single indicator by its code (e.g., "1.1", "1.1.1", "2.3").

This endpoint is for hard-coded SGLGB indicators that are defined in Python
and seeded into the database.

**Path Parameters**:
- indicator_code: Indicator code (e.g., "1.1", "1.1.1")

**Query Parameters**:
- year: Assessment year for placeholder resolution (optional, uses active year if not provided)

**Returns**: Indicator with checklist items (if sub-indicator) or children (if parent)
             with resolved year placeholders

**Raises**:
- 404: Indicator not found

**Example**:
```
GET /api/v1/indicators/code/1.1.1
```
 * @summary Get indicator by code (hard-coded indicators)
 */
export const getIndicatorsCode$IndicatorCode = (
    indicatorCode: string,
    params?: GetIndicatorsCodeIndicatorCodeParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<SimplifiedIndicatorResponse>(
      {url: `/api/v1/indicators/code/${indicatorCode}`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetIndicatorsCodeIndicatorCodeQueryKey = (indicatorCode?: string,
    params?: GetIndicatorsCodeIndicatorCodeParams,) => {
    return [
    `/api/v1/indicators/code/${indicatorCode}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetIndicatorsCodeIndicatorCodeQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError = HTTPValidationError>(indicatorCode: string,
    params?: GetIndicatorsCodeIndicatorCodeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsCodeIndicatorCodeQueryKey(indicatorCode,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>> = ({ signal }) => getIndicatorsCode$IndicatorCode(indicatorCode,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorCode),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsCodeIndicatorCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>>
export type GetIndicatorsCodeIndicatorCodeQueryError = HTTPValidationError


/**
 * @summary Get indicator by code (hard-coded indicators)
 */

export function useGetIndicatorsCodeIndicatorCode<TData = Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError = HTTPValidationError>(
 indicatorCode: string,
    params?: GetIndicatorsCodeIndicatorCodeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsCodeIndicatorCodeQueryOptions(indicatorCode,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a full indicator tree (parent with all children and checklist items).

This endpoint returns the complete hierarchy for a parent indicator
(e.g., "1.1" returns 1.1 with children 1.1.1, 1.1.2, and all checklist items).

**Path Parameters**:
- indicator_code: Parent indicator code (e.g., "1.1", "2.3")

**Query Parameters**:
- year: Assessment year for placeholder resolution (optional, uses active year if not provided)

**Returns**: Complete indicator tree with all children and checklist items
             with resolved year placeholders

**Raises**:
- 404: Indicator not found
- 400: Indicator is not a parent (has no children)

**Example**:
```
GET /api/v1/indicators/code/1.1/tree
```

Returns indicator 1.1 with:
- 1.1.1 (with 7 checklist items)
- 1.1.2 (with 1 checklist item)
 * @summary Get full indicator tree by code
 */
export const getIndicatorsCode$IndicatorCodeTree = (
    indicatorCode: string,
    params?: GetIndicatorsCodeIndicatorCodeTreeParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorTreeResponse>(
      {url: `/api/v1/indicators/code/${indicatorCode}/tree`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetIndicatorsCodeIndicatorCodeTreeQueryKey = (indicatorCode?: string,
    params?: GetIndicatorsCodeIndicatorCodeTreeParams,) => {
    return [
    `/api/v1/indicators/code/${indicatorCode}/tree`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetIndicatorsCodeIndicatorCodeTreeQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError = HTTPValidationError>(indicatorCode: string,
    params?: GetIndicatorsCodeIndicatorCodeTreeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsCodeIndicatorCodeTreeQueryKey(indicatorCode,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>> = ({ signal }) => getIndicatorsCode$IndicatorCodeTree(indicatorCode,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorCode),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsCodeIndicatorCodeTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>>
export type GetIndicatorsCodeIndicatorCodeTreeQueryError = HTTPValidationError


/**
 * @summary Get full indicator tree by code
 */

export function useGetIndicatorsCodeIndicatorCodeTree<TData = Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError = HTTPValidationError>(
 indicatorCode: string,
    params?: GetIndicatorsCodeIndicatorCodeTreeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsCodeIndicatorCodeTreeQueryOptions(indicatorCode,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




