/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyTestCalculationApiV1IndicatorsTestCalculationPost,
  BulkIndicatorCreate,
  BulkIndicatorResponse,
  CalculationSchema,
  FormSchema,
  FormSchemaResponse,
  GetIndicatorsDraftsParams,
  GetIndicatorsParams,
  GetIndicatorsTreeGovernanceAreaId200Item,
  HTTPValidationError,
  IndicatorCreate,
  IndicatorDraftCreate,
  IndicatorDraftDeltaUpdate,
  IndicatorDraftResponse,
  IndicatorDraftSummary,
  IndicatorDraftUpdate,
  IndicatorHistoryResponse,
  IndicatorResponse,
  IndicatorTreeResponse,
  IndicatorUpdate,
  IndicatorValidationRequest,
  IndicatorValidationResponse,
  PostIndicatorsTestCalculation200,
  PostIndicatorsValidateCalculationSchema200,
  PostIndicatorsValidateFormSchema200,
  ReorderRequest,
  SimplifiedIndicatorResponse
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Create a new indicator with version 1.

**Permissions**: MLGOO_DILG only

**Request Body**:
- name: Indicator name (min 3 characters)
- description: Optional description
- governance_area_id: ID of governance area
- parent_id: Optional parent indicator ID (for hierarchical structure)
- is_active: Active status (default: True)
- is_profiling_only: Profiling-only flag (default: False)
- is_auto_calculable: Auto-calculable Pass/Fail flag (default: False)
- form_schema: Optional form schema (JSON)
- calculation_schema: Optional calculation schema (JSON)
- remark_schema: Optional remark schema (JSON)
- technical_notes_text: Optional technical notes

**Returns**: Created indicator with version 1
 * @summary Create a new indicator
 */
export const postIndicators = (
    indicatorCreate: IndicatorCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: indicatorCreate, signal
    },
      options);
    }
  


export const getPostIndicatorsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext> => {

const mutationKey = ['postIndicators'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicators>>, {data: IndicatorCreate}> = (props) => {
          const {data} = props ?? {};

          return  postIndicators(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicators>>>
    export type PostIndicatorsMutationBody = IndicatorCreate
    export type PostIndicatorsMutationError = HTTPValidationError

    /**
 * @summary Create a new indicator
 */
export const usePostIndicators = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicators>>,
        TError,
        {data: IndicatorCreate},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * List indicators with optional filtering.

**Permissions**: All authenticated users

**Query Parameters**:
- governance_area_id: Filter by governance area (optional)
- is_active: Filter by active status (optional)
- skip: Pagination offset (default: 0)
- limit: Max records (default: 100, max: 1000)

**Returns**: List of indicators matching filters
 * @summary List all indicators
 */
export const getIndicators = (
    params?: GetIndicatorsParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse[]>(
      {url: `http://localhost:8000/api/v1/indicators/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIndicatorsQueryKey = (params?: GetIndicatorsParams,) => {
    return [`http://localhost:8000/api/v1/indicators/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIndicatorsQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators>>, TError = HTTPValidationError>(params?: GetIndicatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators>>> = ({ signal }) => getIndicators(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators>>>
export type GetIndicatorsQueryError = HTTPValidationError


/**
 * @summary List all indicators
 */

export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = HTTPValidationError>(
 params?: GetIndicatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Validate a form schema without saving it.

**Permissions**: MLGOO_DILG only

**Request Body**:
- form_schema: FormSchema object with fields to validate

**Returns**:
- `{"valid": true}` if the schema is valid
- `{"valid": false, "errors": [...]}` if validation fails with detailed error messages

**Validation Checks**:
- Field IDs are unique
- No circular references in conditional logic
- Conditional MOV references point to existing fields
- Checkbox/Radio fields have at least one option
- Fields list is not empty

**Status Codes**:
- 200: Schema is valid
- 400: Schema is invalid (returns error details)
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not MLGOO_DILG role)
 * @summary Validate a form schema
 */
export const postIndicatorsValidateFormSchema = (
    formSchema: FormSchema,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostIndicatorsValidateFormSchema200>(
      {url: `http://localhost:8000/api/v1/indicators/validate-form-schema`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: formSchema, signal
    },
      options);
    }
  


export const getPostIndicatorsValidateFormSchemaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchema}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchema}, TContext> => {

const mutationKey = ['postIndicatorsValidateFormSchema'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, {data: FormSchema}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsValidateFormSchema(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsValidateFormSchemaMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>>
    export type PostIndicatorsValidateFormSchemaMutationBody = FormSchema
    export type PostIndicatorsValidateFormSchemaMutationError = HTTPValidationError

    /**
 * @summary Validate a form schema
 */
export const usePostIndicatorsValidateFormSchema = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchema}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>,
        TError,
        {data: FormSchema},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsValidateFormSchemaMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Validate a calculation schema without saving it.

**Permissions**: MLGOO_DILG only

**Request Body**:
- calculation_schema: CalculationSchema object with condition groups and rules

**Returns**:
- `{"valid": true}` if the schema is valid
- `{"valid": false, "errors": [...]}` if validation fails

**Validation Checks**:
- All rule types are valid and properly structured
- Field references are present (basic structure validation)
- Nested conditions are properly formed
- Operators are valid for each rule type

**Status Codes**:
- 200: Schema is valid
- 400: Schema is invalid (returns error details)
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not MLGOO_DILG role)

**Note**: This endpoint only validates the schema structure.
To test the schema with actual data, use the `/test-calculation` endpoint.
 * @summary Validate a calculation schema
 */
export const postIndicatorsValidateCalculationSchema = (
    calculationSchema: CalculationSchema,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostIndicatorsValidateCalculationSchema200>(
      {url: `http://localhost:8000/api/v1/indicators/validate-calculation-schema`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: calculationSchema, signal
    },
      options);
    }
  


export const getPostIndicatorsValidateCalculationSchemaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>, TError,{data: CalculationSchema}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>, TError,{data: CalculationSchema}, TContext> => {

const mutationKey = ['postIndicatorsValidateCalculationSchema'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>, {data: CalculationSchema}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsValidateCalculationSchema(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsValidateCalculationSchemaMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>>
    export type PostIndicatorsValidateCalculationSchemaMutationBody = CalculationSchema
    export type PostIndicatorsValidateCalculationSchemaMutationError = HTTPValidationError

    /**
 * @summary Validate a calculation schema
 */
export const usePostIndicatorsValidateCalculationSchema = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>, TError,{data: CalculationSchema}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsValidateCalculationSchema>>,
        TError,
        {data: CalculationSchema},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsValidateCalculationSchemaMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Test a calculation schema with sample assessment data.

**Permissions**: MLGOO_DILG only

**Request Body**:
- calculation_schema: CalculationSchema to evaluate
- assessment_data: Dictionary of field_id -> value pairs
  Example: {"completion_rate": 85, "required_documents": ["doc1", "doc2", "doc3"]}

**Returns**:
```json
{
  "result": "Pass" | "Fail",
  "evaluation_result": true | false,
  "explanation": "Detailed explanation of evaluation",
  "output_status_on_pass": "Pass",
  "output_status_on_fail": "Fail"
}
```

**Status Codes**:
- 200: Calculation completed successfully
- 400: Invalid schema or data (e.g., field not found, type mismatch)
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not MLGOO_DILG role)

**Error Examples**:
- Field not found: `{"detail": "Field 'completion_rate' not found in assessment data. Available fields: ['other_field']"}`
- Type mismatch: `{"detail": "Field 'count' expected list for checkbox count, got str"}`

**Example Usage**:
```json
{
  "calculation_schema": {
    "condition_groups": [
      {
        "operator": "AND",
        "rules": [
          {
            "rule_type": "PERCENTAGE_THRESHOLD",
            "field_id": "completion_rate",
            "operator": ">=",
            "threshold": 75.0
          }
        ]
      }
    ],
    "output_status_on_pass": "Pass",
    "output_status_on_fail": "Fail"
  },
  "assessment_data": {
    "completion_rate": 85
  }
}
```
 * @summary Test a calculation schema with sample data
 */
export const postIndicatorsTestCalculation = (
    bodyTestCalculationApiV1IndicatorsTestCalculationPost: BodyTestCalculationApiV1IndicatorsTestCalculationPost,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostIndicatorsTestCalculation200>(
      {url: `http://localhost:8000/api/v1/indicators/test-calculation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyTestCalculationApiV1IndicatorsTestCalculationPost, signal
    },
      options);
    }
  


export const getPostIndicatorsTestCalculationMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>, TError,{data: BodyTestCalculationApiV1IndicatorsTestCalculationPost}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>, TError,{data: BodyTestCalculationApiV1IndicatorsTestCalculationPost}, TContext> => {

const mutationKey = ['postIndicatorsTestCalculation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>, {data: BodyTestCalculationApiV1IndicatorsTestCalculationPost}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsTestCalculation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsTestCalculationMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>>
    export type PostIndicatorsTestCalculationMutationBody = BodyTestCalculationApiV1IndicatorsTestCalculationPost
    export type PostIndicatorsTestCalculationMutationError = HTTPValidationError

    /**
 * @summary Test a calculation schema with sample data
 */
export const usePostIndicatorsTestCalculation = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsTestCalculation>>, TError,{data: BodyTestCalculationApiV1IndicatorsTestCalculationPost}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsTestCalculation>>,
        TError,
        {data: BodyTestCalculationApiV1IndicatorsTestCalculationPost},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsTestCalculationMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get a specific indicator by ID.

**Permissions**: All authenticated users

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: Indicator details including current version

**Raises**:
- 404: Indicator not found
 * @summary Get indicator by ID
 */
export const getIndicators$IndicatorId = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsIndicatorIdQueryKey = (indicatorId: number,) => {
    return [`http://localhost:8000/api/v1/indicators/${indicatorId}`] as const;
    }

    
export const getGetIndicatorsIndicatorIdQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorIdQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators$IndicatorId>>> = ({ signal }) => getIndicators$IndicatorId(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators$IndicatorId>>>
export type GetIndicatorsIndicatorIdQueryError = HTTPValidationError


/**
 * @summary Get indicator by ID
 */

export function useGetIndicatorsIndicatorId<TData = Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorIdQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an indicator.

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- indicator_id: ID of the indicator to update

**Request Body**: All fields optional for partial updates
- name: Indicator name (min 3 characters)
- description: Description
- governance_area_id: ID of governance area
- parent_id: Parent indicator ID
- is_active: Active status
- is_profiling_only: Profiling-only flag
- is_auto_calculable: Auto-calculable Pass/Fail flag
- form_schema: Form schema (JSON)
- calculation_schema: Calculation schema (JSON)
- remark_schema: Remark schema (JSON)
- technical_notes_text: Technical notes

**Versioning Logic**:
- If any schema field (form_schema, calculation_schema, remark_schema) changes,
  the current version is archived to indicators_history and version is incremented
- Metadata changes (name, description, etc.) do not trigger versioning

**Returns**: Updated indicator

**Raises**:
- 404: Indicator not found
- 400: Circular parent reference detected
- 400: Invalid governance_area_id
 * @summary Update an indicator
 */
export const putIndicators$IndicatorId = (
    indicatorId: number,
    indicatorUpdate: IndicatorUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: indicatorUpdate
    },
      options);
    }
  


export const getPutIndicatorsIndicatorIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext> => {

const mutationKey = ['putIndicatorsIndicatorId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, {indicatorId: number;data: IndicatorUpdate}> = (props) => {
          const {indicatorId,data} = props ?? {};

          return  putIndicators$IndicatorId(indicatorId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIndicatorsIndicatorIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIndicators$IndicatorId>>>
    export type PutIndicatorsIndicatorIdMutationBody = IndicatorUpdate
    export type PutIndicatorsIndicatorIdMutationError = HTTPValidationError

    /**
 * @summary Update an indicator
 */
export const usePutIndicatorsIndicatorId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putIndicators$IndicatorId>>,
        TError,
        {indicatorId: number;data: IndicatorUpdate},
        TContext
      > => {

      const mutationOptions = getPutIndicatorsIndicatorIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Deactivate an indicator (soft delete).

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- indicator_id: ID of the indicator to deactivate

**Returns**: Deactivated indicator (is_active=False)

**Raises**:
- 404: Indicator not found
- 400: Cannot deactivate indicator with active child indicators
 * @summary Deactivate an indicator
 */
export const deleteIndicators$IndicatorId = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIndicatorsIndicatorIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext> => {

const mutationKey = ['deleteIndicatorsIndicatorId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, {indicatorId: number}> = (props) => {
          const {indicatorId} = props ?? {};

          return  deleteIndicators$IndicatorId(indicatorId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIndicatorsIndicatorIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>>
    
    export type DeleteIndicatorsIndicatorIdMutationError = HTTPValidationError

    /**
 * @summary Deactivate an indicator
 */
export const useDeleteIndicatorsIndicatorId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>,
        TError,
        {indicatorId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIndicatorsIndicatorIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get version history for an indicator.

**Permissions**: All authenticated users

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: List of archived versions ordered by version DESC (newest first)

**Raises**:
- 404: Indicator not found
 * @summary Get indicator version history
 */
export const getIndicators$IndicatorIdHistory = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorHistoryResponse[]>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}/history`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsIndicatorIdHistoryQueryKey = (indicatorId: number,) => {
    return [`http://localhost:8000/api/v1/indicators/${indicatorId}/history`] as const;
    }

    
export const getGetIndicatorsIndicatorIdHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorIdHistoryQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>> = ({ signal }) => getIndicators$IndicatorIdHistory(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorIdHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>>
export type GetIndicatorsIndicatorIdHistoryQueryError = HTTPValidationError


/**
 * @summary Get indicator version history
 */

export function useGetIndicatorsIndicatorIdHistory<TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorIdHistoryQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get form schema for a specific indicator.

**Permissions**: All authenticated users
- BLGU users: Can access all indicators (all barangays complete all governance areas)
- Assessors and validators: Can access all indicators

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: Form schema with metadata (title, description, governance area)

**Raises**:
- 404: Indicator not found
 * @summary Get form schema for an indicator
 */
export const getIndicators$IndicatorIdFormSchema = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<FormSchemaResponse>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}/form-schema`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsIndicatorIdFormSchemaQueryKey = (indicatorId: number,) => {
    return [`http://localhost:8000/api/v1/indicators/${indicatorId}/form-schema`] as const;
    }

    
export const getGetIndicatorsIndicatorIdFormSchemaQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorIdFormSchemaQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>> = ({ signal }) => getIndicators$IndicatorIdFormSchema(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorIdFormSchemaQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>>
export type GetIndicatorsIndicatorIdFormSchemaQueryError = HTTPValidationError


/**
 * @summary Get form schema for an indicator
 */

export function useGetIndicatorsIndicatorIdFormSchema<TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdFormSchema>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorIdFormSchemaQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get hierarchical tree structure of indicators for a governance area.

**Permissions**: All authenticated users

**Path Parameters**:
- governance_area_id: Governance area ID

**Returns**: List of root indicator nodes with nested children

**Tree Structure**:
```json
[
    {
        "id": 1,
        "name": "Root Indicator",
        "indicator_code": "1.1",
        "sort_order": 0,
        "selection_mode": "none",
        "parent_id": null,
        "children": [
            {
                "id": 2,
                "name": "Child Indicator",
                "indicator_code": "1.1.1",
                "sort_order": 0,
                "parent_id": 1,
                "children": []
            }
        ]
    }
]
```

**Features**:
- Hierarchical parent-child relationships
- Automatic code generation (1.1, 1.1.1, etc.)
- MOV checklist items included
- Form, calculation, and remark schemas included

**Raises**:
- 404: Governance area not found
 * @summary Get indicator tree structure
 */
export const getIndicatorsTree$GovernanceAreaId = (
    governanceAreaId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetIndicatorsTreeGovernanceAreaId200Item[]>(
      {url: `http://localhost:8000/api/v1/indicators/tree/${governanceAreaId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsTreeGovernanceAreaIdQueryKey = (governanceAreaId: number,) => {
    return [`http://localhost:8000/api/v1/indicators/tree/${governanceAreaId}`] as const;
    }

    
export const getGetIndicatorsTreeGovernanceAreaIdQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError = HTTPValidationError>(governanceAreaId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsTreeGovernanceAreaIdQueryKey(governanceAreaId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>> = ({ signal }) => getIndicatorsTree$GovernanceAreaId(governanceAreaId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(governanceAreaId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsTreeGovernanceAreaIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>>
export type GetIndicatorsTreeGovernanceAreaIdQueryError = HTTPValidationError


/**
 * @summary Get indicator tree structure
 */

export function useGetIndicatorsTreeGovernanceAreaId<TData = Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError = HTTPValidationError>(
 governanceAreaId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsTree$GovernanceAreaId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsTreeGovernanceAreaIdQueryOptions(governanceAreaId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Recalculate indicator codes for a governance area after reordering.

Automatically generates hierarchical codes like "1.1", "1.1.1", "1.2"
based on tree structure and sort_order.

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- governance_area_id: Governance area ID

**Returns**: List of updated indicators with new codes

**Code Generation Logic**:
- Root nodes: "1", "2", "3", ...
- First-level children: "1.1", "1.2", "1.3", ...
- Second-level children: "1.1.1", "1.1.2", ...
- Sort order determines numbering within siblings

**Example**:
Before reorder:
- Indicator A (code: "1.1", sort_order: 1)
- Indicator B (code: "1.2", sort_order: 0)

After recalculate (sorted by sort_order):
- Indicator B (code: "1.1", sort_order: 0)
- Indicator A (code: "1.2", sort_order: 1)

**Raises**:
- 404: Governance area not found
 * @summary Recalculate indicator codes
 */
export const postIndicatorsRecalculateCodes$GovernanceAreaId = (
    governanceAreaId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse[]>(
      {url: `http://localhost:8000/api/v1/indicators/recalculate-codes/${governanceAreaId}`, method: 'POST', signal
    },
      options);
    }
  


export const getPostIndicatorsRecalculateCodesGovernanceAreaIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>, TError,{governanceAreaId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>, TError,{governanceAreaId: number}, TContext> => {

const mutationKey = ['postIndicatorsRecalculateCodesGovernanceAreaId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>, {governanceAreaId: number}> = (props) => {
          const {governanceAreaId} = props ?? {};

          return  postIndicatorsRecalculateCodes$GovernanceAreaId(governanceAreaId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsRecalculateCodesGovernanceAreaIdMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>>
    
    export type PostIndicatorsRecalculateCodesGovernanceAreaIdMutationError = HTTPValidationError

    /**
 * @summary Recalculate indicator codes
 */
export const usePostIndicatorsRecalculateCodesGovernanceAreaId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>, TError,{governanceAreaId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsRecalculateCodes$GovernanceAreaId>>,
        TError,
        {governanceAreaId: number},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsRecalculateCodesGovernanceAreaIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Create multiple indicators in bulk with proper dependency ordering.

**Permissions**: MLGOO_DILG only

**Request Body**:
- governance_area_id: Governance area ID for all indicators
- indicators: List of indicators with temp_id, parent_temp_id, order, and standard indicator fields

**Returns**: BulkIndicatorResponse with created indicators, temp_id_mapping, and errors

**Features**:
- Automatic topological sorting to ensure parents are created before children
- Transaction rollback if any errors occur
- Temp ID to real ID mapping for frontend

**Raises**:
- 404: Governance area not found
- 400: Circular dependencies detected
- 500: Bulk creation failed
 * @summary Create multiple indicators in bulk
 */
export const postIndicatorsBulk = (
    bulkIndicatorCreate: BulkIndicatorCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<BulkIndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bulkIndicatorCreate, signal
    },
      options);
    }
  


export const getPostIndicatorsBulkMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsBulk>>, TError,{data: BulkIndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsBulk>>, TError,{data: BulkIndicatorCreate}, TContext> => {

const mutationKey = ['postIndicatorsBulk'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsBulk>>, {data: BulkIndicatorCreate}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsBulk(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsBulkMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsBulk>>>
    export type PostIndicatorsBulkMutationBody = BulkIndicatorCreate
    export type PostIndicatorsBulkMutationError = HTTPValidationError

    /**
 * @summary Create multiple indicators in bulk
 */
export const usePostIndicatorsBulk = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsBulk>>, TError,{data: BulkIndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsBulk>>,
        TError,
        {data: BulkIndicatorCreate},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsBulkMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reorder indicators by updating codes and parent_ids in batch.

**Permissions**: MLGOO_DILG only

**Request Body**:
- indicators: List of indicator updates with id, code, parent_id

**Returns**: List of updated indicators

**Raises**:
- 400: Circular references detected
- 500: Reorder failed
 * @summary Reorder indicators
 */
export const postIndicatorsReorder = (
    reorderRequest: ReorderRequest,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse[]>(
      {url: `http://localhost:8000/api/v1/indicators/reorder`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reorderRequest, signal
    },
      options);
    }
  


export const getPostIndicatorsReorderMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsReorder>>, TError,{data: ReorderRequest}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsReorder>>, TError,{data: ReorderRequest}, TContext> => {

const mutationKey = ['postIndicatorsReorder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsReorder>>, {data: ReorderRequest}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsReorder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsReorderMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsReorder>>>
    export type PostIndicatorsReorderMutationBody = ReorderRequest
    export type PostIndicatorsReorderMutationError = HTTPValidationError

    /**
 * @summary Reorder indicators
 */
export const usePostIndicatorsReorder = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsReorder>>, TError,{data: ReorderRequest}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsReorder>>,
        TError,
        {data: ReorderRequest},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsReorderMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Create a new indicator draft for the wizard workflow.

**Permissions**: MLGOO_DILG only

**Request Body**:
- governance_area_id: Governance area ID
- creation_mode: Creation mode ('incremental' or 'bulk_import')
- title: Optional draft title
- data: Optional initial draft data (list of indicator nodes)

**Returns**: Created draft with UUID

**Raises**:
- 404: Governance area not found
- 404: User not found
 * @summary Create a new indicator draft
 */
export const postIndicatorsDrafts = (
    indicatorDraftCreate: IndicatorDraftCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorDraftResponse>(
      {url: `http://localhost:8000/api/v1/indicators/drafts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: indicatorDraftCreate, signal
    },
      options);
    }
  


export const getPostIndicatorsDraftsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts>>, TError,{data: IndicatorDraftCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts>>, TError,{data: IndicatorDraftCreate}, TContext> => {

const mutationKey = ['postIndicatorsDrafts'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsDrafts>>, {data: IndicatorDraftCreate}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsDrafts(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsDraftsMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsDrafts>>>
    export type PostIndicatorsDraftsMutationBody = IndicatorDraftCreate
    export type PostIndicatorsDraftsMutationError = HTTPValidationError

    /**
 * @summary Create a new indicator draft
 */
export const usePostIndicatorsDrafts = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts>>, TError,{data: IndicatorDraftCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsDrafts>>,
        TError,
        {data: IndicatorDraftCreate},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsDraftsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * List all drafts for the current user with optional filtering.

**Permissions**: MLGOO_DILG only

**Query Parameters**:
- governance_area_id: Filter by governance area (optional)
- status: Filter by status (optional)

**Returns**: List of draft summaries ordered by last accessed (most recent first)
 * @summary List user's indicator drafts
 */
export const getIndicatorsDrafts = (
    params?: GetIndicatorsDraftsParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorDraftSummary[]>(
      {url: `http://localhost:8000/api/v1/indicators/drafts`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIndicatorsDraftsQueryKey = (params?: GetIndicatorsDraftsParams,) => {
    return [`http://localhost:8000/api/v1/indicators/drafts`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIndicatorsDraftsQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsDrafts>>, TError = HTTPValidationError>(params?: GetIndicatorsDraftsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsDrafts>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsDraftsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsDrafts>>> = ({ signal }) => getIndicatorsDrafts(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsDrafts>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsDraftsQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsDrafts>>>
export type GetIndicatorsDraftsQueryError = HTTPValidationError


/**
 * @summary List user's indicator drafts
 */

export function useGetIndicatorsDrafts<TData = Awaited<ReturnType<typeof getIndicatorsDrafts>>, TError = HTTPValidationError>(
 params?: GetIndicatorsDraftsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsDrafts>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsDraftsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Load an indicator draft by ID.

**Permissions**: MLGOO_DILG only (must own the draft)

**Path Parameters**:
- draft_id: Draft UUID

**Returns**: Full draft data

**Raises**:
- 404: Draft not found
- 403: Access denied (not draft owner)
 * @summary Get indicator draft by ID
 */
export const getIndicatorsDrafts$DraftId = (
    draftId: string,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorDraftResponse>(
      {url: `http://localhost:8000/api/v1/indicators/drafts/${draftId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsDraftsDraftIdQueryKey = (draftId: string,) => {
    return [`http://localhost:8000/api/v1/indicators/drafts/${draftId}`] as const;
    }

    
export const getGetIndicatorsDraftsDraftIdQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsDrafts$DraftId>>, TError = HTTPValidationError>(draftId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsDrafts$DraftId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsDraftsDraftIdQueryKey(draftId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsDrafts$DraftId>>> = ({ signal }) => getIndicatorsDrafts$DraftId(draftId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(draftId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsDrafts$DraftId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsDraftsDraftIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsDrafts$DraftId>>>
export type GetIndicatorsDraftsDraftIdQueryError = HTTPValidationError


/**
 * @summary Get indicator draft by ID
 */

export function useGetIndicatorsDraftsDraftId<TData = Awaited<ReturnType<typeof getIndicatorsDrafts$DraftId>>, TError = HTTPValidationError>(
 draftId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsDrafts$DraftId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsDraftsDraftIdQueryOptions(draftId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an indicator draft with optimistic locking.

**Permissions**: MLGOO_DILG only (must own the draft)

**Path Parameters**:
- draft_id: Draft UUID

**Request Body**:
- current_step: Current wizard step (optional)
- status: Draft status (optional)
- data: Draft indicator data (optional)
- title: Draft title (optional)
- version: Current version number (required for optimistic locking)

**Returns**: Updated draft with incremented version

**Features**:
- Optimistic locking to prevent concurrent edit conflicts
- Automatic lock acquisition
- Lock expiration after 30 minutes

**Raises**:
- 404: Draft not found
- 403: Access denied (not draft owner)
- 409: Version conflict (draft was modified by another process)
- 423: Draft locked by another user
 * @summary Update indicator draft
 */
export const putIndicatorsDrafts$DraftId = (
    draftId: string,
    indicatorDraftUpdate: IndicatorDraftUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorDraftResponse>(
      {url: `http://localhost:8000/api/v1/indicators/drafts/${draftId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: indicatorDraftUpdate
    },
      options);
    }
  


export const getPutIndicatorsDraftsDraftIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicatorsDrafts$DraftId>>, TError,{draftId: string;data: IndicatorDraftUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putIndicatorsDrafts$DraftId>>, TError,{draftId: string;data: IndicatorDraftUpdate}, TContext> => {

const mutationKey = ['putIndicatorsDraftsDraftId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIndicatorsDrafts$DraftId>>, {draftId: string;data: IndicatorDraftUpdate}> = (props) => {
          const {draftId,data} = props ?? {};

          return  putIndicatorsDrafts$DraftId(draftId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIndicatorsDraftsDraftIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIndicatorsDrafts$DraftId>>>
    export type PutIndicatorsDraftsDraftIdMutationBody = IndicatorDraftUpdate
    export type PutIndicatorsDraftsDraftIdMutationError = HTTPValidationError

    /**
 * @summary Update indicator draft
 */
export const usePutIndicatorsDraftsDraftId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicatorsDrafts$DraftId>>, TError,{draftId: string;data: IndicatorDraftUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putIndicatorsDrafts$DraftId>>,
        TError,
        {draftId: string;data: IndicatorDraftUpdate},
        TContext
      > => {

      const mutationOptions = getPutIndicatorsDraftsDraftIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Delete an indicator draft.

**Permissions**: MLGOO_DILG only (must own the draft)

**Path Parameters**:
- draft_id: Draft UUID

**Returns**: 204 No Content on success

**Raises**:
- 404: Draft not found
- 403: Access denied (not draft owner)
 * @summary Delete indicator draft
 */
export const deleteIndicatorsDrafts$DraftId = (
    draftId: string,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<void>(
      {url: `http://localhost:8000/api/v1/indicators/drafts/${draftId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIndicatorsDraftsDraftIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicatorsDrafts$DraftId>>, TError,{draftId: string}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIndicatorsDrafts$DraftId>>, TError,{draftId: string}, TContext> => {

const mutationKey = ['deleteIndicatorsDraftsDraftId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIndicatorsDrafts$DraftId>>, {draftId: string}> = (props) => {
          const {draftId} = props ?? {};

          return  deleteIndicatorsDrafts$DraftId(draftId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIndicatorsDraftsDraftIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIndicatorsDrafts$DraftId>>>
    
    export type DeleteIndicatorsDraftsDraftIdMutationError = HTTPValidationError

    /**
 * @summary Delete indicator draft
 */
export const useDeleteIndicatorsDraftsDraftId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicatorsDrafts$DraftId>>, TError,{draftId: string}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteIndicatorsDrafts$DraftId>>,
        TError,
        {draftId: string},
        TContext
      > => {

      const mutationOptions = getDeleteIndicatorsDraftsDraftIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Update indicator draft with delta-based save (only changed indicators).

This endpoint provides ~95% payload reduction compared to full updates,
improving save performance from 2-3s to <300ms.

**Permissions**: MLGOO_DILG only (must own the draft)

**Path Parameters**:
- draft_id: Draft UUID

**Request Body**:
- changed_indicators: List of changed indicator dictionaries
- changed_ids: List of temp_ids for changed indicators
- version: Current version number (required for optimistic locking)
- metadata: Optional metadata (current_step, status, title)

**Returns**: Updated draft with incremented version

**Features**:
- Delta merge: Only updates changed indicators in existing tree
- 95% payload reduction (600 KB ‚Üí 15 KB typical)
- 10x performance improvement (<300ms vs 2-3s)
- Optimistic locking to prevent concurrent edit conflicts
- Automatic lock acquisition
- Lock expiration after 30 minutes

**Raises**:
- 404: Draft not found
- 403: Access denied (not draft owner)
- 409: Version conflict (draft was modified by another process)
- 423: Draft locked by another user

**Example**:
```json
{
  "changed_indicators": [
    {"temp_id": "abc123", "name": "Updated Indicator", ...},
    {"temp_id": "def456", "name": "Another Update", ...}
  ],
  "changed_ids": ["abc123", "def456"],
  "version": 5,
  "metadata": {"current_step": 3}
}
```
 * @summary Delta update indicator draft (only changed indicators)
 */
export const postIndicatorsDrafts$DraftIdDelta = (
    draftId: string,
    indicatorDraftDeltaUpdate: IndicatorDraftDeltaUpdate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorDraftResponse>(
      {url: `http://localhost:8000/api/v1/indicators/drafts/${draftId}/delta`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: indicatorDraftDeltaUpdate, signal
    },
      options);
    }
  


export const getPostIndicatorsDraftsDraftIdDeltaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdDelta>>, TError,{draftId: string;data: IndicatorDraftDeltaUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdDelta>>, TError,{draftId: string;data: IndicatorDraftDeltaUpdate}, TContext> => {

const mutationKey = ['postIndicatorsDraftsDraftIdDelta'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdDelta>>, {draftId: string;data: IndicatorDraftDeltaUpdate}> = (props) => {
          const {draftId,data} = props ?? {};

          return  postIndicatorsDrafts$DraftIdDelta(draftId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsDraftsDraftIdDeltaMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdDelta>>>
    export type PostIndicatorsDraftsDraftIdDeltaMutationBody = IndicatorDraftDeltaUpdate
    export type PostIndicatorsDraftsDraftIdDeltaMutationError = HTTPValidationError

    /**
 * @summary Delta update indicator draft (only changed indicators)
 */
export const usePostIndicatorsDraftsDraftIdDelta = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdDelta>>, TError,{draftId: string;data: IndicatorDraftDeltaUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdDelta>>,
        TError,
        {draftId: string;data: IndicatorDraftDeltaUpdate},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsDraftsDraftIdDeltaMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Release lock on an indicator draft.

**Permissions**: MLGOO_DILG only (must own the draft and hold the lock)

**Path Parameters**:
- draft_id: Draft UUID

**Returns**: Draft with lock released

**Raises**:
- 404: Draft not found
- 403: Access denied (not draft owner)
- 400: Lock not held by you
 * @summary Release lock on indicator draft
 */
export const postIndicatorsDrafts$DraftIdReleaseLock = (
    draftId: string,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorDraftResponse>(
      {url: `http://localhost:8000/api/v1/indicators/drafts/${draftId}/release-lock`, method: 'POST', signal
    },
      options);
    }
  


export const getPostIndicatorsDraftsDraftIdReleaseLockMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdReleaseLock>>, TError,{draftId: string}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdReleaseLock>>, TError,{draftId: string}, TContext> => {

const mutationKey = ['postIndicatorsDraftsDraftIdReleaseLock'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdReleaseLock>>, {draftId: string}> = (props) => {
          const {draftId} = props ?? {};

          return  postIndicatorsDrafts$DraftIdReleaseLock(draftId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsDraftsDraftIdReleaseLockMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdReleaseLock>>>
    
    export type PostIndicatorsDraftsDraftIdReleaseLockMutationError = HTTPValidationError

    /**
 * @summary Release lock on indicator draft
 */
export const usePostIndicatorsDraftsDraftIdReleaseLock = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdReleaseLock>>, TError,{draftId: string}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsDrafts$DraftIdReleaseLock>>,
        TError,
        {draftId: string},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsDraftsDraftIdReleaseLockMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Validate indicator tree structure, relationships, and schemas before bulk publish.

**Permissions**: MLGOO_DILG only

**Validations Performed**:
- Circular reference detection (DFS algorithm)
- Parent-child relationship integrity
- Indicator code format validation (pattern: `1`, `1.1`, `1.1.1`, etc.)
- Sort order validation (sequential starting from 0)
- Schema completeness (form, MOV, calculation, remark)
- Weight sum validation (siblings must sum to 100%)

**Request Body**:
```json
{
  "indicators": [
    {
      "id": "temp_1",
      "parent_id": null,
      "indicator_code": "1",
      "sort_order": 0,
      "weight": 60,
      "form_schema": {...},
      "calculation_schema": {...},
      "remark_schema": {...}
    },
    {
      "id": "temp_2",
      "parent_id": "temp_1",
      "indicator_code": "1.1",
      "sort_order": 0,
      "weight": 100
    }
  ]
}
```

**Returns**:
```json
{
  "is_valid": true,
  "errors": [],
  "warnings": ["Indicator temp_3 has no indicator_code set"]
}
```

**Error Response Example**:
```json
{
  "is_valid": false,
  "errors": [
    {
      "type": "circular_reference",
      "message": "Circular reference detected: 1 ‚Üí 1.1 ‚Üí 1",
      "indicator_id": "temp_1"
    },
    {
      "type": "invalid_code",
      "message": "Indicator 1. has invalid code format (must match pattern: 1, 1.1, 1.1.1, etc.)",
      "indicator_id": "temp_2"
    },
    {
      "type": "weight_sum",
      "message": "Weights for indicators 1.1, 1.2 sum to 90%, must be 100% (parent temp_1)",
      "indicator_id": null
    }
  ],
  "warnings": []
}
```

**Status Codes**:
- 200: Validation completed (check `is_valid` field)
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not MLGOO_DILG role)
 * @summary Validate indicator tree structure before publishing
 */
export const postIndicatorsValidateTree = (
    indicatorValidationRequest: IndicatorValidationRequest,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorValidationResponse>(
      {url: `http://localhost:8000/api/v1/indicators/validate-tree`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: indicatorValidationRequest, signal
    },
      options);
    }
  


export const getPostIndicatorsValidateTreeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateTree>>, TError,{data: IndicatorValidationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateTree>>, TError,{data: IndicatorValidationRequest}, TContext> => {

const mutationKey = ['postIndicatorsValidateTree'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsValidateTree>>, {data: IndicatorValidationRequest}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsValidateTree(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsValidateTreeMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsValidateTree>>>
    export type PostIndicatorsValidateTreeMutationBody = IndicatorValidationRequest
    export type PostIndicatorsValidateTreeMutationError = HTTPValidationError

    /**
 * @summary Validate indicator tree structure before publishing
 */
export const usePostIndicatorsValidateTree = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateTree>>, TError,{data: IndicatorValidationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsValidateTree>>,
        TError,
        {data: IndicatorValidationRequest},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsValidateTreeMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get a single indicator by its code (e.g., "1.1", "1.1.1", "2.3").

This endpoint is for hard-coded SGLGB indicators that are defined in Python
and seeded into the database.

**Path Parameters**:
- indicator_code: Indicator code (e.g., "1.1", "1.1.1")

**Returns**: Indicator with checklist items (if sub-indicator) or children (if parent)

**Raises**:
- 404: Indicator not found

**Example**:
```
GET /api/v1/indicators/code/1.1.1
```
 * @summary Get indicator by code (hard-coded indicators)
 */
export const getIndicatorsCode$IndicatorCode = (
    indicatorCode: string,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<SimplifiedIndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/code/${indicatorCode}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsCodeIndicatorCodeQueryKey = (indicatorCode: string,) => {
    return [`http://localhost:8000/api/v1/indicators/code/${indicatorCode}`] as const;
    }

    
export const getGetIndicatorsCodeIndicatorCodeQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError = HTTPValidationError>(indicatorCode: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsCodeIndicatorCodeQueryKey(indicatorCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>> = ({ signal }) => getIndicatorsCode$IndicatorCode(indicatorCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorCode),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsCodeIndicatorCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>>
export type GetIndicatorsCodeIndicatorCodeQueryError = HTTPValidationError


/**
 * @summary Get indicator by code (hard-coded indicators)
 */

export function useGetIndicatorsCodeIndicatorCode<TData = Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError = HTTPValidationError>(
 indicatorCode: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCode>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsCodeIndicatorCodeQueryOptions(indicatorCode,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get a full indicator tree (parent with all children and checklist items).

This endpoint returns the complete hierarchy for a parent indicator
(e.g., "1.1" returns 1.1 with children 1.1.1, 1.1.2, and all checklist items).

**Path Parameters**:
- indicator_code: Parent indicator code (e.g., "1.1", "2.3")

**Returns**: Complete indicator tree with all children and checklist items

**Raises**:
- 404: Indicator not found
- 400: Indicator is not a parent (has no children)

**Example**:
```
GET /api/v1/indicators/code/1.1/tree
```

Returns indicator 1.1 with:
- 1.1.1 (with 7 checklist items)
- 1.1.2 (with 1 checklist item)
 * @summary Get full indicator tree by code
 */
export const getIndicatorsCode$IndicatorCodeTree = (
    indicatorCode: string,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorTreeResponse>(
      {url: `http://localhost:8000/api/v1/indicators/code/${indicatorCode}/tree`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsCodeIndicatorCodeTreeQueryKey = (indicatorCode: string,) => {
    return [`http://localhost:8000/api/v1/indicators/code/${indicatorCode}/tree`] as const;
    }

    
export const getGetIndicatorsCodeIndicatorCodeTreeQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError = HTTPValidationError>(indicatorCode: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsCodeIndicatorCodeTreeQueryKey(indicatorCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>> = ({ signal }) => getIndicatorsCode$IndicatorCodeTree(indicatorCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorCode),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsCodeIndicatorCodeTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>>
export type GetIndicatorsCodeIndicatorCodeTreeQueryError = HTTPValidationError


/**
 * @summary Get full indicator tree by code
 */

export function useGetIndicatorsCodeIndicatorCodeTree<TData = Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError = HTTPValidationError>(
 indicatorCode: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsCode$IndicatorCodeTree>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsCodeIndicatorCodeTreeQueryOptions(indicatorCode,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



