/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost,
  HTTPValidationError,
  MOVFileListResponse,
  MOVFileResponse,
  SignedUrlResponse
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Upload a MOV (Means of Verification) file for a specific indicator in an assessment.

    - **Validates** file type (PDF, DOCX, XLSX, JPG, PNG, MP4)
    - **Validates** file size (max 50MB)
    - **Validates** file content security
    - **Uploads** file to Supabase Storage
    - **Creates** database record with metadata

    Returns the uploaded file metadata including URL, size, and upload timestamp.
 * @summary Upload MOV file for an indicator
 */
export const postMovsAssessments$AssessmentIdIndicators$IndicatorIdUpload = (
    assessmentId: number,
    indicatorId: number,
    bodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost: BodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost.file)
if(bodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost.field_id !== undefined && bodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost.field_id !== null) {
 formData.append(`field_id`, bodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost.field_id)
 }
if(bodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost.field_label !== undefined && bodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost.field_label !== null) {
 formData.append(`field_label`, bodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost.field_label)
 }

      return mutator<MOVFileResponse>(
      {url: `/api/v1/movs/assessments/${assessmentId}/indicators/${indicatorId}/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getPostMovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMovsAssessments$AssessmentIdIndicators$IndicatorIdUpload>>, TError,{assessmentId: number;indicatorId: number;data: BodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postMovsAssessments$AssessmentIdIndicators$IndicatorIdUpload>>, TError,{assessmentId: number;indicatorId: number;data: BodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost}, TContext> => {

const mutationKey = ['postMovsAssessmentsAssessmentIdIndicatorsIndicatorIdUpload'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMovsAssessments$AssessmentIdIndicators$IndicatorIdUpload>>, {assessmentId: number;indicatorId: number;data: BodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost}> = (props) => {
          const {assessmentId,indicatorId,data} = props ?? {};

          return  postMovsAssessments$AssessmentIdIndicators$IndicatorIdUpload(assessmentId,indicatorId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadMutationResult = NonNullable<Awaited<ReturnType<typeof postMovsAssessments$AssessmentIdIndicators$IndicatorIdUpload>>>
    export type PostMovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadMutationBody = BodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost
    export type PostMovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadMutationError = HTTPValidationError

    /**
 * @summary Upload MOV file for an indicator
 */
export const usePostMovsAssessmentsAssessmentIdIndicatorsIndicatorIdUpload = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMovsAssessments$AssessmentIdIndicators$IndicatorIdUpload>>, TError,{assessmentId: number;indicatorId: number;data: BodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postMovsAssessments$AssessmentIdIndicators$IndicatorIdUpload>>,
        TError,
        {assessmentId: number;indicatorId: number;data: BodyUploadMovFileApiV1MovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadPost},
        TContext
      > => {

      const mutationOptions = getPostMovsAssessmentsAssessmentIdIndicatorsIndicatorIdUploadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Retrieve all MOV (Means of Verification) files for a specific indicator in an assessment.

    - **Permission-based filtering**: BLGU users see only their own files, Assessors/Validators see all files
    - **Excludes soft-deleted files**: Only active files are returned
    - **Ordered by upload time**: Most recent files first

    Returns a list of file metadata including URL, size, type, and uploader information.
 * @summary List MOV files for an indicator
 */
export const getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles = (
    assessmentId: number,
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<MOVFileListResponse>(
      {url: `/api/v1/movs/assessments/${assessmentId}/indicators/${indicatorId}/files`, method: 'GET', signal
    },
      options);
    }
  



export const getGetMovsAssessmentsAssessmentIdIndicatorsIndicatorIdFilesQueryKey = (assessmentId?: number,
    indicatorId?: number,) => {
    return [
    `/api/v1/movs/assessments/${assessmentId}/indicators/${indicatorId}/files`
    ] as const;
    }

    
export const getGetMovsAssessmentsAssessmentIdIndicatorsIndicatorIdFilesQueryOptions = <TData = Awaited<ReturnType<typeof getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles>>, TError = HTTPValidationError>(assessmentId: number,
    indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMovsAssessmentsAssessmentIdIndicatorsIndicatorIdFilesQueryKey(assessmentId,indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles>>> = ({ signal }) => getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles(assessmentId,indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assessmentId && indicatorId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMovsAssessmentsAssessmentIdIndicatorsIndicatorIdFilesQueryResult = NonNullable<Awaited<ReturnType<typeof getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles>>>
export type GetMovsAssessmentsAssessmentIdIndicatorsIndicatorIdFilesQueryError = HTTPValidationError


/**
 * @summary List MOV files for an indicator
 */

export function useGetMovsAssessmentsAssessmentIdIndicatorsIndicatorIdFiles<TData = Awaited<ReturnType<typeof getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles>>, TError = HTTPValidationError>(
 assessmentId: number,
    indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMovsAssessments$AssessmentIdIndicators$IndicatorIdFiles>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMovsAssessmentsAssessmentIdIndicatorsIndicatorIdFilesQueryOptions(assessmentId,indicatorId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Generate a time-limited signed URL for secure access to a MOV file.

    - **Permission check**: Validates user has access to the file
    - **Time-limited**: URL expires after 1 hour by default
    - **Secure**: Only authenticated users can generate URLs

    Returns a signed URL that can be used to access the file directly.
 * @summary Get a signed URL for a MOV file
 */
export const getMovsFiles$FileIdSignedUrl = (
    fileId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<SignedUrlResponse>(
      {url: `/api/v1/movs/files/${fileId}/signed-url`, method: 'GET', signal
    },
      options);
    }
  



export const getGetMovsFilesFileIdSignedUrlQueryKey = (fileId?: number,) => {
    return [
    `/api/v1/movs/files/${fileId}/signed-url`
    ] as const;
    }

    
export const getGetMovsFilesFileIdSignedUrlQueryOptions = <TData = Awaited<ReturnType<typeof getMovsFiles$FileIdSignedUrl>>, TError = HTTPValidationError>(fileId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMovsFiles$FileIdSignedUrl>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMovsFilesFileIdSignedUrlQueryKey(fileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMovsFiles$FileIdSignedUrl>>> = ({ signal }) => getMovsFiles$FileIdSignedUrl(fileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(fileId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMovsFiles$FileIdSignedUrl>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMovsFilesFileIdSignedUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getMovsFiles$FileIdSignedUrl>>>
export type GetMovsFilesFileIdSignedUrlQueryError = HTTPValidationError


/**
 * @summary Get a signed URL for a MOV file
 */

export function useGetMovsFilesFileIdSignedUrl<TData = Awaited<ReturnType<typeof getMovsFiles$FileIdSignedUrl>>, TError = HTTPValidationError>(
 fileId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMovsFiles$FileIdSignedUrl>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMovsFilesFileIdSignedUrlQueryOptions(fileId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete a MOV (Means of Verification) file from both storage and database.

    - **Performs soft delete**: Sets deleted_at timestamp instead of removing record
    - **Permission check**: Only the uploader can delete their own files
    - **Status restriction**: Only allowed for DRAFT or NEEDS_REWORK assessments
    - **Storage cleanup**: Removes file from Supabase Storage

    Returns the deleted file metadata with updated deleted_at timestamp.
 * @summary Delete a MOV file
 */
export const deleteMovsFiles$FileId = (
    fileId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<MOVFileResponse>(
      {url: `/api/v1/movs/files/${fileId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteMovsFilesFileIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMovsFiles$FileId>>, TError,{fileId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMovsFiles$FileId>>, TError,{fileId: number}, TContext> => {

const mutationKey = ['deleteMovsFilesFileId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMovsFiles$FileId>>, {fileId: number}> = (props) => {
          const {fileId} = props ?? {};

          return  deleteMovsFiles$FileId(fileId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMovsFilesFileIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMovsFiles$FileId>>>
    
    export type DeleteMovsFilesFileIdMutationError = HTTPValidationError

    /**
 * @summary Delete a MOV file
 */
export const useDeleteMovsFilesFileId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMovsFiles$FileId>>, TError,{fileId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteMovsFiles$FileId>>,
        TError,
        {fileId: number},
        TContext
      > => {

      const mutationOptions = getDeleteMovsFilesFileIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    