/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApprovalQueueResponse,
  ApproveAssessmentResponse,
  AssessmentDetailResponse,
  GetMlgooApprovalQueueParams,
  HTTPValidationError,
  PostMlgooAssessmentsAssessmentIdApproveBody,
  PostMlgooAssessmentsAssessmentIdUnlockBody,
  RecalibrationRequest,
  RecalibrationResponse,
  UnlockAssessmentResponse,
  UpdateRecalibrationValidationRequest,
  UpdateRecalibrationValidationResponse
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get list of assessments awaiting MLGOO final approval.

**Access:** Requires MLGOO_DILG role.

Returns assessments in AWAITING_MLGOO_APPROVAL status that have been validated by all governance area validators and are ready for final approval.
 * @summary Get MLGOO Approval Queue
 */
export const getMlgooApprovalQueue = (
    params?: GetMlgooApprovalQueueParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<ApprovalQueueResponse>(
      {url: `/api/v1/mlgoo/approval-queue`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetMlgooApprovalQueueQueryKey = (params?: GetMlgooApprovalQueueParams,) => {
    return [
    `/api/v1/mlgoo/approval-queue`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetMlgooApprovalQueueQueryOptions = <TData = Awaited<ReturnType<typeof getMlgooApprovalQueue>>, TError = void | HTTPValidationError>(params?: GetMlgooApprovalQueueParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMlgooApprovalQueue>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMlgooApprovalQueueQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMlgooApprovalQueue>>> = ({ signal }) => getMlgooApprovalQueue(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMlgooApprovalQueue>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMlgooApprovalQueueQueryResult = NonNullable<Awaited<ReturnType<typeof getMlgooApprovalQueue>>>
export type GetMlgooApprovalQueueQueryError = void | HTTPValidationError


/**
 * @summary Get MLGOO Approval Queue
 */

export function useGetMlgooApprovalQueue<TData = Awaited<ReturnType<typeof getMlgooApprovalQueue>>, TError = void | HTTPValidationError>(
 params?: GetMlgooApprovalQueueParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMlgooApprovalQueue>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMlgooApprovalQueueQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get detailed assessment information for MLGOO review.

**Access:** Requires MLGOO_DILG role.

Returns comprehensive assessment data including all governance areas, indicator validation statuses, and RE-calibration information.
 * @summary Get Assessment Details for MLGOO Review
 */
export const getMlgooAssessments$AssessmentId = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentDetailResponse>(
      {url: `/api/v1/mlgoo/assessments/${assessmentId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetMlgooAssessmentsAssessmentIdQueryKey = (assessmentId?: number,) => {
    return [
    `/api/v1/mlgoo/assessments/${assessmentId}`
    ] as const;
    }

    
export const getGetMlgooAssessmentsAssessmentIdQueryOptions = <TData = Awaited<ReturnType<typeof getMlgooAssessments$AssessmentId>>, TError = void | HTTPValidationError>(assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMlgooAssessments$AssessmentId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMlgooAssessmentsAssessmentIdQueryKey(assessmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMlgooAssessments$AssessmentId>>> = ({ signal }) => getMlgooAssessments$AssessmentId(assessmentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assessmentId),  staleTime: 30000, refetchOnWindowFocus: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMlgooAssessments$AssessmentId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMlgooAssessmentsAssessmentIdQueryResult = NonNullable<Awaited<ReturnType<typeof getMlgooAssessments$AssessmentId>>>
export type GetMlgooAssessmentsAssessmentIdQueryError = void | HTTPValidationError


/**
 * @summary Get Assessment Details for MLGOO Review
 */

export function useGetMlgooAssessmentsAssessmentId<TData = Awaited<ReturnType<typeof getMlgooAssessments$AssessmentId>>, TError = void | HTTPValidationError>(
 assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMlgooAssessments$AssessmentId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMlgooAssessmentsAssessmentIdQueryOptions(assessmentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Approve an assessment and move it to COMPLETED status.

**Access:** Requires MLGOO_DILG role.

This is the final step in the assessment workflow. Once approved, the assessment is officially complete and the BLGU is notified.

**Requirements:**
- Assessment must be in AWAITING_MLGOO_APPROVAL status
- All governance areas must have been validated
 * @summary Approve Assessment
 */
export const postMlgooAssessments$AssessmentIdApprove = (
    assessmentId: number,
    postMlgooAssessmentsAssessmentIdApproveBody: PostMlgooAssessmentsAssessmentIdApproveBody,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<ApproveAssessmentResponse>(
      {url: `/api/v1/mlgoo/assessments/${assessmentId}/approve`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postMlgooAssessmentsAssessmentIdApproveBody, signal
    },
      options);
    }
  


export const getPostMlgooAssessmentsAssessmentIdApproveMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdApprove>>, TError,{assessmentId: number;data: PostMlgooAssessmentsAssessmentIdApproveBody}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdApprove>>, TError,{assessmentId: number;data: PostMlgooAssessmentsAssessmentIdApproveBody}, TContext> => {

const mutationKey = ['postMlgooAssessmentsAssessmentIdApprove'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdApprove>>, {assessmentId: number;data: PostMlgooAssessmentsAssessmentIdApproveBody}> = (props) => {
          const {assessmentId,data} = props ?? {};

          return  postMlgooAssessments$AssessmentIdApprove(assessmentId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMlgooAssessmentsAssessmentIdApproveMutationResult = NonNullable<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdApprove>>>
    export type PostMlgooAssessmentsAssessmentIdApproveMutationBody = PostMlgooAssessmentsAssessmentIdApproveBody
    export type PostMlgooAssessmentsAssessmentIdApproveMutationError = void | HTTPValidationError

    /**
 * @summary Approve Assessment
 */
export const usePostMlgooAssessmentsAssessmentIdApprove = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdApprove>>, TError,{assessmentId: number;data: PostMlgooAssessmentsAssessmentIdApproveBody}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdApprove>>,
        TError,
        {assessmentId: number;data: PostMlgooAssessmentsAssessmentIdApproveBody},
        TContext
      > => {

      const mutationOptions = getPostMlgooAssessmentsAssessmentIdApproveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Request RE-calibration for specific indicators.

**Access:** Requires MLGOO_DILG role.

MLGOO can request RE-calibration when they believe the Validator was too strict on certain indicators. This sends the assessment back to BLGU for corrections.

**Important:**
- RE-calibration can only be requested ONCE per assessment
- Must specify which indicators need RE-calibration
- Comments explaining the reason are required
- A 3-day grace period is automatically set for BLGU to respond
 * @summary Request RE-calibration
 */
export const postMlgooAssessments$AssessmentIdRecalibrate = (
    assessmentId: number,
    recalibrationRequest: RecalibrationRequest,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<RecalibrationResponse>(
      {url: `/api/v1/mlgoo/assessments/${assessmentId}/recalibrate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: recalibrationRequest, signal
    },
      options);
    }
  


export const getPostMlgooAssessmentsAssessmentIdRecalibrateMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdRecalibrate>>, TError,{assessmentId: number;data: RecalibrationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdRecalibrate>>, TError,{assessmentId: number;data: RecalibrationRequest}, TContext> => {

const mutationKey = ['postMlgooAssessmentsAssessmentIdRecalibrate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdRecalibrate>>, {assessmentId: number;data: RecalibrationRequest}> = (props) => {
          const {assessmentId,data} = props ?? {};

          return  postMlgooAssessments$AssessmentIdRecalibrate(assessmentId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMlgooAssessmentsAssessmentIdRecalibrateMutationResult = NonNullable<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdRecalibrate>>>
    export type PostMlgooAssessmentsAssessmentIdRecalibrateMutationBody = RecalibrationRequest
    export type PostMlgooAssessmentsAssessmentIdRecalibrateMutationError = void | HTTPValidationError

    /**
 * @summary Request RE-calibration
 */
export const usePostMlgooAssessmentsAssessmentIdRecalibrate = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdRecalibrate>>, TError,{assessmentId: number;data: RecalibrationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdRecalibrate>>,
        TError,
        {assessmentId: number;data: RecalibrationRequest},
        TContext
      > => {

      const mutationOptions = getPostMlgooAssessmentsAssessmentIdRecalibrateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Unlock an assessment that was locked due to deadline expiry.

**Access:** Requires MLGOO_DILG role.

When a BLGU misses their grace period deadline, their assessment is automatically locked. MLGOO can unlock it and grant additional time for the BLGU to complete their corrections.

**Default behavior:**
- Unlocks the assessment
- Extends grace period by 3 days (configurable)
 * @summary Unlock Deadline-Locked Assessment
 */
export const postMlgooAssessments$AssessmentIdUnlock = (
    assessmentId: number,
    postMlgooAssessmentsAssessmentIdUnlockBody: PostMlgooAssessmentsAssessmentIdUnlockBody,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<UnlockAssessmentResponse>(
      {url: `/api/v1/mlgoo/assessments/${assessmentId}/unlock`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postMlgooAssessmentsAssessmentIdUnlockBody, signal
    },
      options);
    }
  


export const getPostMlgooAssessmentsAssessmentIdUnlockMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdUnlock>>, TError,{assessmentId: number;data: PostMlgooAssessmentsAssessmentIdUnlockBody}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdUnlock>>, TError,{assessmentId: number;data: PostMlgooAssessmentsAssessmentIdUnlockBody}, TContext> => {

const mutationKey = ['postMlgooAssessmentsAssessmentIdUnlock'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdUnlock>>, {assessmentId: number;data: PostMlgooAssessmentsAssessmentIdUnlockBody}> = (props) => {
          const {assessmentId,data} = props ?? {};

          return  postMlgooAssessments$AssessmentIdUnlock(assessmentId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMlgooAssessmentsAssessmentIdUnlockMutationResult = NonNullable<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdUnlock>>>
    export type PostMlgooAssessmentsAssessmentIdUnlockMutationBody = PostMlgooAssessmentsAssessmentIdUnlockBody
    export type PostMlgooAssessmentsAssessmentIdUnlockMutationError = void | HTTPValidationError

    /**
 * @summary Unlock Deadline-Locked Assessment
 */
export const usePostMlgooAssessmentsAssessmentIdUnlock = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdUnlock>>, TError,{assessmentId: number;data: PostMlgooAssessmentsAssessmentIdUnlockBody}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postMlgooAssessments$AssessmentIdUnlock>>,
        TError,
        {assessmentId: number;data: PostMlgooAssessmentsAssessmentIdUnlockBody},
        TContext
      > => {

      const mutationOptions = getPostMlgooAssessmentsAssessmentIdUnlockMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Update the validation status of recalibration target indicators.

**Access:** Requires MLGOO_DILG role.

After a BLGU resubmits their MOVs for recalibration target indicators, MLGOO can review and update the validation status (Pass, Fail, Conditional) before approving the assessment.

**Important:**
- Only recalibration target indicators can be updated
- Assessment must be in AWAITING_MLGOO_APPROVAL status
- This does NOT automatically approve the assessment - call approve endpoint separately
 * @summary Update Validation Status of Recalibration Targets
 */
export const patchMlgooAssessments$AssessmentIdRecalibrationValidation = (
    assessmentId: number,
    updateRecalibrationValidationRequest: UpdateRecalibrationValidationRequest,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<UpdateRecalibrationValidationResponse>(
      {url: `/api/v1/mlgoo/assessments/${assessmentId}/recalibration-validation`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateRecalibrationValidationRequest
    },
      options);
    }
  


export const getPatchMlgooAssessmentsAssessmentIdRecalibrationValidationMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchMlgooAssessments$AssessmentIdRecalibrationValidation>>, TError,{assessmentId: number;data: UpdateRecalibrationValidationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof patchMlgooAssessments$AssessmentIdRecalibrationValidation>>, TError,{assessmentId: number;data: UpdateRecalibrationValidationRequest}, TContext> => {

const mutationKey = ['patchMlgooAssessmentsAssessmentIdRecalibrationValidation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchMlgooAssessments$AssessmentIdRecalibrationValidation>>, {assessmentId: number;data: UpdateRecalibrationValidationRequest}> = (props) => {
          const {assessmentId,data} = props ?? {};

          return  patchMlgooAssessments$AssessmentIdRecalibrationValidation(assessmentId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchMlgooAssessmentsAssessmentIdRecalibrationValidationMutationResult = NonNullable<Awaited<ReturnType<typeof patchMlgooAssessments$AssessmentIdRecalibrationValidation>>>
    export type PatchMlgooAssessmentsAssessmentIdRecalibrationValidationMutationBody = UpdateRecalibrationValidationRequest
    export type PatchMlgooAssessmentsAssessmentIdRecalibrationValidationMutationError = void | HTTPValidationError

    /**
 * @summary Update Validation Status of Recalibration Targets
 */
export const usePatchMlgooAssessmentsAssessmentIdRecalibrationValidation = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchMlgooAssessments$AssessmentIdRecalibrationValidation>>, TError,{assessmentId: number;data: UpdateRecalibrationValidationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchMlgooAssessments$AssessmentIdRecalibrationValidation>>,
        TError,
        {assessmentId: number;data: UpdateRecalibrationValidationRequest},
        TContext
      > => {

      const mutationOptions = getPatchMlgooAssessmentsAssessmentIdRecalibrationValidationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    