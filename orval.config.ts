import { defineConfig } from 'orval';
import fs from 'fs';

/**
 * Reads a simple key=value .env file and returns an object
 */
function loadEnvFile(filePath: string): Record<string, string> {
  const env: Record<string, string> = {};
  if (fs.existsSync(filePath)) {
    const content = fs.readFileSync(filePath, 'utf-8');
    content.split('\n').forEach((line) => {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) return;

      const [key, ...valueParts] = trimmed.split('=');
      if (key && valueParts.length > 0) {
        env[key.trim()] = valueParts.join('=').trim();
      }
    });
  }
  return env;
}

/**
 * Gets the API port from various sources in priority order:
 * 1. ORVAL_API_URL environment variable (full URL)
 * 2. API_PORT environment variable
 * 3. Root .env file (API_PORT)
 * 4. .worktree-info file (API_PORT)
 * 5. Default: 8000
 */
function getOpenApiUrl(): string {
  // 1. Check for full URL override first
  if (process.env.ORVAL_API_URL) {
    return process.env.ORVAL_API_URL;
  }

  // 2. Check API_PORT environment variable
  if (process.env.API_PORT) {
    return `http://localhost:${process.env.API_PORT}/openapi.json`;
  }

  // 3. Check root .env file
  const rootEnv = loadEnvFile('.env');
  if (rootEnv.API_PORT) {
    return `http://localhost:${rootEnv.API_PORT}/openapi.json`;
  }

  // 4. Check .worktree-info file (for worktree setups)
  const worktreeInfo = loadEnvFile('.worktree-info');
  if (worktreeInfo.API_PORT) {
    return `http://localhost:${worktreeInfo.API_PORT}/openapi.json`;
  }

  // 5. Default fallback
  return 'http://localhost:8000/openapi.json';
}

// Allow overriding the OpenAPI URL via environment variable for CI/CD
// Also supports worktree development with dynamic ports
const openApiUrl = getOpenApiUrl();

export default defineConfig({
  sinag: {
    input: {
      target: openApiUrl,
    },
    output: {
      // ğŸ¯ Professional scaling approach: Split by FastAPI tags automatically!
      // This creates organized folders based on your FastAPI route tags
      mode: 'tags-split',
      
      // ğŸ“ API endpoints will be organized by tag in subfolders
      target: 'packages/shared/src/generated/endpoints',
      
      // ğŸ“ Schemas (types) get their own dedicated folder  
      schemas: 'packages/shared/src/generated/schemas',
      
      client: 'react-query',
      // Don't hardcode baseUrl - let the mutator set it dynamically
      // This allows for proper SSR support and environment-based URLs

      override: {
        // ğŸ”§ Use our custom Axios instance with authentication & error handling
        mutator: {
          path: './apps/web/src/lib/api.ts',
          name: 'mutator', // Use named export instead of default
        },
        query: {
          useQuery: true,
          useMutation: true,
          useInfinite: false,
          options: {
            staleTime: 30 * 1000, // 30 seconds - allows faster invalidation after mutations
            refetchOnWindowFocus: true, // Enable automatic refetch when user returns to tab
          },
        },
        operationName: (operation, route, verb) => {
          // Replace /api/v1 prefix and slashes
          const path = route.replace('/api/v1', '').replace(/[\/{}]/g, ' ');
          const toCamelCase = (str: string) =>
            str.replace(/[-_]([a-z])/g, (g) => g[1].toUpperCase());

          // Split into parts and format
          const parts = path.split(' ').filter(Boolean);
          const operationId = parts
            .map(toCamelCase)
            .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
            .join('');
          
          return `${verb}${operationId}`;
        },
        header: () => [
          '// ğŸš€ Auto-generated by Orval (Axios + React Query)',
          '// ğŸ”„ Do not edit manually - regenerate with: pnpm generate-types',
          '// ğŸ“ Organized by FastAPI tags for maximum maintainability',
          '// ğŸ” Uses custom Axios instance with auth & error handling',
          '',
        ],
      },
    },
  },
}); 